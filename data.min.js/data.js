/** 
 * @fileoverview
 * provides an object and methods to load, parse and process various data sources.<br>
 * The <b>sources</b> may be of the following type: <b>csv</b>, <b>json</b>, <b>geojson</b>, <b>kml</b>, <b>gml</b>, <b>rss</b>, <b>parquet</b> (using DuckDB WASM), <b>geopackage</b> (using DuckDB WASM), <b>flatgeobuf</b>, and <b>geobuf</b>.<br>
 * The <b>methods</b> to load data are: 
 * <ul><li>Data.<b>feed()</b> to load from url</li>
 * <li>Data.<b>import()</b> to import javascript objects and</li>
 * <li>Data.<b>broker()</b> to load more than one source</li></ul>
 * The loaded data is stored in a Table object which gives the user the methods to transform the data.<br>
 * The format of the data of a Table object is jsonDB, the same format used internaly by iXmaps.
 * @example 
 *
 *  // define data source
 *  var szUrl = "https://raw.githubusercontent.com/emergenzeHack/terremotocentro/master/_data/issues.csv";
 *
 *  // load data from feed
 *  var myfeed = Data.feed({"source":szUrl,"type":"csv"}).load(function(mydata){
 *
 *      // on data load succeeds, process the loaded data via mydata object
 *      // create new columns 'date' and 'hour' from one timestamp column
 *      // we need them to create pivot tables 
 *      // ---------------------------------------------------------------
 *      mydata.addColumn({'source':'created_at','destination':'date'},function(value){
 *          var d = new Date(__normalizeTime(value));
 *          return( String(d.getDate()) + "." + String(d.getMonth()+1) + "." + String(d.getFullYear()) );
 *      });
 *
 *      // get the hours
 *      // -----------------------------------------
 *      var hoursA = mydata.column("hour").values();
 *
 *      // do something ... 
 *
 *      // make a pivot table from the values in column 'state'
 *      // ----------------------------------------------------
 *      var pivot = mydata.pivot({ "lead":	'date',
 *                                 "keep":  ['created_at'],	
 *                                 "cols":	'state' 
 *                               });
 *
 *      // invert data table (let the last record be the first)
 *      // ----------------------------------------------
 *      pivot = pivot.revert();
 *
 *      // make chart with 2 curves, total and closed issues
 *      // -------------------------------------------------
 *      var set1  = pivot.column("Total").values();
 *      var set2  = pivot.column("closed").values();
 *
 *     ....
 * }).error(function(e){
 *      alert("Data.feed error: " + e);
 * });
 *
 * @author Guenter Richter guenter.richter@medienobjekte.de
 * @version 1.58 
 * @copyright CC BY SA
 * @license MIT
 */
!function(e,t,o){new Date;_LOG=function(e){new Date};const r=function(e){return e&&void 0!==e?function(e){return"[object Array]"===Object.prototype.toString.call(e)}(e)?e:String(e).match(/\|/)?String(e).split("|"):String(e).split(","):[]},n=function(e,t,o){return o.indexOf(e)===t};var s={version:"1.58",errors:[],log:function(e){},cleanupDuckDB:function(){try{if(e.duckdb){if(e.duckdb.conn)try{e.duckdb.conn.close()}catch(e){}if(e.duckdb.db)try{e.duckdb.db.terminate()}catch(e){}if(e.duckdb.worker)try{e.duckdb.worker.terminate()}catch(e){}delete e.duckdb,delete e.duckdbLoaded,delete e.duckdbLoadedForGpkg,delete e.duckdbLoadError}}catch(e){}},batchConfig:{baseParquetBatchSize:2e5,baseWorkerBatchSize:5e5,baseExtractBatchSize:2e5,memoryScalingFactor:1,maxMemoryMB:512,minWorkerBatchSize:5e5,maxWorkerBatchSize:5e6,maxCellsPerBatch:1e7,enablePerformanceMonitoring:!1,adaptiveBatchSizing:!1},getOptimizedBatchSize:function(e,t,o){const r=this.batchConfig;let n;switch(e){case"parquet":n=r.baseParquetBatchSize;break;case"worker":n=r.baseWorkerBatchSize;break;case"extract":n=r.baseExtractBatchSize;break;default:n=r.baseParquetBatchSize}return Math.min(n,t)},performanceMonitor:{batchTimes:[],memoryUsage:[],adaptiveAdjustments:[],recordBatchPerformance:function(e,t,o,r){if(!s.batchConfig.enablePerformanceMonitoring)return;const n={timestamp:Date.now(),batchType:e,batchSize:t,processingTime:o,memoryUsed:r,throughput:t/(o/1e3)};this.batchTimes.push(n),this.memoryUsage.push(r),this.batchTimes.length>100&&(this.batchTimes.shift(),this.memoryUsage.shift())},getPerformanceStats:function(e){const t=this.batchTimes.filter((t=>t.batchType===e));if(0===t.length)return null;const o=t.reduce(((e,t)=>e+t.throughput),0)/t.length,r=t.reduce(((e,t)=>e+t.processingTime),0)/t.length,n=t.reduce(((e,t)=>e+t.memoryUsed),0)/t.length;return{batchType:e,recordCount:t.length,avgThroughput:o,avgProcessingTime:r,avgMemoryUsed:n,recommendedBatchSize:this.calculateOptimalBatchSize(e,t)}},calculateOptimalBatchSize:function(e,t){if(t.length<3)return null;const o=t.reduce(((e,t)=>t.throughput>e.throughput?t:e)),r=this.memoryUsage.slice(-10);return r.reduce(((e,t)=>e+t),0)/r.length>.8*s.batchConfig.maxMemoryMB?Math.floor(.8*o.batchSize):o.memoryUsed<.5*s.batchConfig.maxMemoryMB?Math.floor(1.2*o.batchSize):o.batchSize},logPerformanceSummary:function(){if(!s.batchConfig.enablePerformanceMonitoring)return;["parquet","worker","extract"].forEach((e=>{const t=this.getPerformanceStats(e);t&&t.recommendedBatchSize}))}}};"object"==typeof module&&"object"==typeof module.exports?module.exports=s:"function"==typeof define&&define.amd&&define(s),void 0!==e&&function(){const t=e.Data;s.noConflict=function(){return e.Data=t,this},e.Data=s}(),s.Object=function(e){this.options=e,this.debug=!1},s.Object.prototype={import:function(e){return this.options.success=this.options.success||e,this.feed=s.feed({}),this.feed.options=this.options,"csv"==this.options.type||"CSV"==this.options.type?this.feed.__processCSVData(this.options.source,this.options):"rss"==this.options.type||"RSS"==this.options.type?(this.options.format="xml",this.feed.__processRSSData(this.options.source,this.options)):"kml"==this.options.type||"KML"==this.options.type?(this.options.format="xml",this.feed.__processKMLData(this.options.source,this.options)):"gml"==this.options.type||"GML"==this.options.type?(this.options.format="xml",this.feed.__processGMLData(this.options.source,this.options)):"json"==this.options.type||"JSON"==this.options.type||"Json"==this.options.type?this.feed.__processJsonData(this.options.source,this.options):"jsonl"==this.options.type||"JSONL"==this.options.type||"ndjson"==this.options.type||"NDJSON"==this.options.type?this.feed.__processJSONLinesData(this.options.source,this.options):"geojson"==this.options.type||"GEOJSON"==this.options.type||"GeoJson"==this.options.type?this.feed.__processGeoJsonData(this.options.source,this.options):"topojson"==this.options.type||"TOPOJSON"==this.options.type||"TopoJson"==this.options.type?this.feed.__processTopoJsonData(this.options.source,this.options):"jsonDB"==this.options.type||"JSONDB"==this.options.type||"JsonDB"==this.options.type||"jsondb"==this.options.type?this.feed.__processJsonDBData(this.options.source,this.options):"parquet"==this.options.type||"PARQUET"==this.options.type?this.options.source instanceof ArrayBuffer&&(_LOG("Processing parquet ArrayBuffer directly: "+this.options.source.byteLength+" bytes"),this.feed.__processParquetData(this.options.source,this.options)):"geoparquet"==this.options.type||"GEOPARQUET"==this.options.type?this.options.source instanceof ArrayBuffer&&(_LOG("Processing geoparquet ArrayBuffer directly: "+this.options.source.byteLength+" bytes"),this.feed.__processGeoParquetData(this.options.source,this.options)):"gpkg"==this.options.type||"GPKG"==this.options.type||"geopackage"==this.options.type||"GEOPACKAGE"==this.options.type?this.options.source instanceof ArrayBuffer&&(_LOG("Processing GeoPackage ArrayBuffer directly: "+this.options.source.byteLength+" bytes"),this.feed.__processGpkgData(this.options.source,this.options)):"fgb"==this.options.type||"FGB"==this.options.type||"flatgeobuf"==this.options.type||"FLATGEOBUF"==this.options.type||"FlatGeobuf"==this.options.type?this.options.source instanceof ArrayBuffer&&(_LOG("Processing FlatGeobuf ArrayBuffer directly: "+this.options.source.byteLength+" bytes"),this.feed.__processFlatGeobufData(this.options.source,this.options)):"pbf"!=this.options.type&&"PBF"!=this.options.type&&"geobuf"!=this.options.type&&"GEOBUF"!=this.options.type&&"Geobuf"!=this.options.type||this.options.source instanceof ArrayBuffer&&(_LOG("Processing Geobuf ArrayBuffer directly: "+this.options.source.byteLength+" bytes"),this.feed.__processGeobufData(this.options.source,this.options)),this},error:function(e){return this.options.error=e,this}},s.Import=function(e){this.options=e,this.debug=!1},s.Feed=function(e){this.options=e||{},this.debug=!1,this.options.error=function(e){s.errors.push(e)}},s.Feed.prototype={load:function(e){this.options.success=e;const t=this.options,o=t.source||t.src||t.url||t.ext;void 0===t.cache&&(t.cache=!0,t.options&&void 0!==t.options.cache&&(t.cache=t.options.cache));const r=this;if(o||a("Data.feed(...).load(): no source defined !",2e3),!t.type&&o){const e=o.split("?")[0].toLowerCase();(e.endsWith(".jsonl")||e.endsWith(".ndjson"))&&(t.type="jsonl")}return"csv"==t.type||"CSV"==t.type?this.__doCSVImport(o,t):"rss"==t.type||"RSS"==t.type?this.__doRSSImport(o,t):"kml"==t.type||"KML"==t.type?this.__doKMLImport(o,t):"gml"==t.type||"GML"==t.type?this.__doGMLImport(o,t):"json"==t.type||"JSON"==t.type||"Json"==t.type?this.__doJSONImport(o,t):"jsonl"==t.type||"JSONL"==t.type||"ndjson"==t.type||"NDJSON"==t.type?this.__doJSONLinesImport(o,t):"geojson"==t.type||"GEOJSON"==t.type||"GeoJson"==t.type?this.__doGeoJSONImport(o,t):"topojson"==t.type||"TOPOJSON"==t.type||"TopoJson"==t.type?this.__doTopoJSONImport(o,t):"jsonDB"==t.type||"JSONDB"==t.type||"JsonDB"==t.type||"jsondb"==t.type?this.__doJsonDBImport(o,t):"jsonstat"==t.type||"jsonStat"==t.type||"JSONSTAT"==t.type?$.getScript("http://json-stat.org/lib/json-stat.js").done((function(e,n){r.__doLoadJSONstat(o,t)})).fail((function(e,o,r){a("'"+t.type+"' unknown format !")})):"parquet"==t.type||"PARQUET"==t.type?this.__doParquetImport(o,t):"gpkg"==t.type||"GPKG"==t.type||"geopackage"==t.type||"GEOPACKAGE"==t.type?this.__doGpkgImport(o,t):"fgb"==t.type||"FGB"==t.type||"flatgeobuf"==t.type||"FLATGEOBUF"==t.type||"FlatGeobuf"==t.type?this.__doFlatGeobufImport(o,t):"pbf"==t.type||"PBF"==t.type||"geobuf"==t.type||"GEOBUF"==t.type||"Geobuf"==t.type?this.__doGeobufImport(o,t):a("'"+t.type+"' unknown format !"),this},error:function(e){return this.options.error=e,this},getFileSize:function(e){const t=this.options,o=t.source||t.src||t.url||t.ext;if(!o){const t="Data.feed(...).getFileSize(): no source defined!";return e&&"function"==typeof e?(e(null),this):Promise.reject(new Error(t))}const r=new Promise(((e,t)=>{if("undefined"!=typeof XMLHttpRequest){const t=new XMLHttpRequest;t.open("GET",o,!0),t.onreadystatechange=function(){if(2===t.readyState)try{const o=t.getResponseHeader("Content-Length");if(o&&""!==o.trim()&&"0"!==o.trim()){const r=parseInt(o.trim(),10);if(!isNaN(r)&&r>0)return t.abort(),void e(r)}}catch(e){}else if(4===t.readyState){if(200===t.status||206===t.status)try{const o=t.getResponseHeader("Content-Length");if(o&&""!==o.trim()&&"0"!==o.trim()){const t=parseInt(o.trim(),10);if(!isNaN(t)&&t>0)return void e(t)}}catch(e){}"undefined"!=typeof fetch?fetch(o,{method:"GET",headers:{Range:"bytes=0-0"}}).then((t=>{const r=t.headers.get("content-range");if(r){const t=r.match(/\/(\d+)/);if(t&&t[1]){const o=parseInt(t[1],10);if(!isNaN(o)&&o>0)return void e(o)}}return fetch(o,{method:"GET"})})).then((t=>{if(t){const o=t.headers.get("content-length");if(o&&""!==o.trim()&&"0"!==o.trim()){const t=parseInt(o.trim(),10);!isNaN(t)&&t>0?e(t):e(null)}else e(null)}else e(null)})).catch((()=>e(null))):e(null)}},t.onerror=function(){"undefined"!=typeof fetch?fetch(o,{method:"GET"}).then((t=>{const o=t.headers.get("content-length");if(o&&""!==o.trim()){const t=parseInt(o.trim(),10);!isNaN(t)&&t>0?e(t):e(null)}else e(null)})).catch((()=>e(null))):e(null)},t.send()}else"undefined"!=typeof fetch?fetch(o,{method:"GET"}).then((t=>{if(!t.ok)throw new Error("Response not OK");const r=t.headers.get("content-length");if(r&&""!==r.trim()){const t=parseInt(r.trim(),10);if(!isNaN(t)&&t>0)return void e(t)}return fetch(o,{method:"GET",headers:{Range:"bytes=0-0"}}).then((t=>{const o=t.headers.get("content-range");if(o){const t=o.match(/\/(\d+)/);if(t&&t[1]){const o=parseInt(t[1],10);if(!isNaN(o)&&o>0)return void e(o)}}if(200===t.status||206===t.status){const o=t.headers.get("content-length");if(o&&""!==o.trim()&&200===t.status){const t=parseInt(o.trim(),10);if(!isNaN(t)&&t>0)return void e(t)}}e(null)})).catch((()=>e(null)))})).catch((t=>{"undefined"!=typeof $&&$.ajax?$.ajax({url:o,type:"GET",success:function(t,o,r){const n=r.getResponseHeader("Content-Length");if(n){const t=parseInt(n,10);!isNaN(t)&&t>0?e(t):e(null)}else e(null)},error:function(){e(null)}}):e(null)})):"undefined"!=typeof $&&$.ajax?$.ajax({url:o,type:"GET",success:function(t,o,r){const n=r.getResponseHeader("Content-Length");if(n){const t=parseInt(n,10);!isNaN(t)&&t>0?e(t):e(null)}else e(null)},error:function(){e(null)}}):t(new Error("Neither fetch API nor jQuery available for file size request"))}));return e&&"function"==typeof e?(r.then((t=>e(t))).catch((t=>{this.options.error&&"function"==typeof this.options.error&&this.options.error("getFileSize error: "+t.message),e(null)})),this):r}},s.feed=function(e){return new s.Feed(e)},s.object=function(e){return new s.Object(e)},s.import=function(e){return new s.Object(e).import().feed.dbtable};s.Feed.prototype.__doLoadJSONstat=function(e,t){const o=this;JSONstat(e,(function(){const e=[];let r=[this.Dataset(0).Dimension(0).label];const n=this.Dataset(0).Dimension(1).id;for(let e=0;e<n.length;e++)r.push(this.Dataset(0).Dimension(1).Category(n[e]).label);e.push(r);for(let t=0;t<this.Dataset(0).Dimension(0).length;t++){r=[],r.push(this.Dataset(0).Dimension(0).Category(this.Dataset(0).Dimension(0).id[t]).label);for(let e=0;e<this.Dataset(0).Dimension(1).length;e++)r.push(this.Dataset(0).Data([t,e]).value);e.push(r)}t.callback?t.callback(e,t):o.__createDataTableObject(e,t.type,t)}))},s.Feed.prototype.__doJsonDBImport=function(e,t){_LOG("__doJsonDBImport: "+e);const o=this;t.url=e,$.getScript(e+".gz").done((function(e,r){o.__processJsonDBData(e,t)})).fail((function(r,n,s){$.getScript(e).done((function(e,r){o.__processJsonDBData(e,t)})).fail((function(t,r,n){o.options.error&&o.options.error('"'+e+'" '+n)}))}))},s.Feed.prototype.__processJsonDBData=function(t,o){_LOG("__processJsonDBData:"),this.dbtable=new s.Table;let r=null;if("string"==typeof t){const t=o.source.split(/\//).pop().split(/\./)[0];r=void 0!==e?e[t]:global[t]}else r=o.source;this.dbtable.table=r.table,this.dbtable.fields=r.fields,this.dbtable.records=r.records,o.callback?o.callback(newData,o):void 0!==o&&o.success&&o.success(this.dbtable)},s.Feed.prototype.__doCSVImport=function(e,t){_LOG("__doCSVImport: "+e);const o=this;$.ajax({type:"GET",url:e,cache:t.cache,dataType:"text",success:function(e){o.__processCSVData(e,t)},error:function(o,r,n){void 0!==t&&t.error&&t.error('"'+e+'" '+n)}})},s.Feed.prototype.__processCSVData=function(e,t){if(_LOG("__processCSVData - start"),"undefined"==typeof Papa){_LOG("__processCSVData:load csv parser!");const o=this;return $.getScript("https://cdnjs.cloudflare.com/ajax/libs/PapaParse/4.1.2/papaparse.min.js").done((function(r,n){o.__processCSVData(e,t)})).fail((function(e,o,r){a("'"+t.type+"' parser not loaded !"),t.error&&t.error("'"+t.type+"' parser not loaded !")})),!1}let o=Papa.parse(e,t.parser);if(o.errors.length)return a("csv parsing error: "+o.errors.map((e=>e.message)).join(";")),t.error&&t.error("csv parsing error: "+o.errors.map((e=>e.message)).join(";")),!1;let r=o.data;if(r.length<2||void 0===r[0]||void 0===r[1])return a("csv parsing error: insufficient rows in data !"),t.error&&t.error("csv parsing error: insufficient rows in data !"),!1;if(!(t.parser&&t.parser.delimiter||r[0].length===r[1].length)){_LOG("csv parser: autodetect failed");const o=[";",","];let n=!1;for(const t of o){if(_LOG(`csv parser: delimiter = ${t}`),r=Papa.parse(e,{delimiter:t}).data,r[0].length===r[1].length){n=!0;break}_LOG(`csv parser: delimiter = ${t} failed`)}if(!n)return a("csv parsing error: unable to auto detect delimiter!"),t.error&&t.error("csv parsing error: unable to auto detect delimiter!"),!1}return r[r.length-1].length!==r[0].length&&r.length>1&&r.pop(),r[0].length-r[1].length==1&&""===r[0][r[0].length-1].trim()&&r[0].pop(),t.callback?(t.callback(r,t),!1):(_LOG("__createDataTableObject: "+(t.options?" -> "+t.options.name:"")),this.__createDataTableObject(r,t.type,t),!1)},s.Feed.prototype.__doRSSImport=function(e,t){_LOG("__doRSSImport: "+e);const o=this;t.format="xml",$.ajax({type:"GET",url:e,dataType:"xml",success:function(e){o.__processRSSData(e,t)},error:function(e,o,r){void 0!==t&&t.error&&t.error(e,o,r)}})},s.Feed.prototype.__processRSSData=function(e,t){"xml"==t.format&&($(e).find("rss").length?this.__parseRSSData(e,t):$(e).find("feed").length?a("feed not yet supported"):$(e).find("atom").length&&a("atom not yet supported"))},s.Feed.prototype.__parseRSSData=function(e,t){const o=this;"xml"==t.format&&$(e).find("channel").each((function(){const r=[];let n=null;$(e).find("item").each((function(){if(!n){const e=[];n=[];const t=$(this).children();for(let o=0;o<t.length;o++){let t=$(this).children()[o].nodeName;for(;e[t];)t+="*";e[t]=t,n[o]=t}r.push(n)}const e=[];for(let t=0;t<n.length;t++)"enclosure"==n[t]?e.push($(this).find(n[t]+":first").attr("url")||""):e.push($(this).find(n[t]+":first").text()||"");r.push(e)})),o.__createDataTableObject(r,"rss",t)}))},s.Feed.prototype.__doKMLImport=function(e,t){_LOG("__doKMLImport: "+e);const o=this;t.format="xml",$.ajax({type:"GET",url:e,dataType:"xml",success:function(e){o.__processKMLData(e,t)},error:function(e,o,r){void 0!==t&&t.error&&t.error(e,o,r)}})},s.Feed.prototype.__doGMLImport=function(e,t){_LOG("__doGMLImport: "+e);const o=this;t.format="xml",$.ajax({type:"GET",url:e,dataType:"xml",success:function(e){o.__processGMLData(e,t)},error:function(e,o,r){void 0!==t&&t.error&&t.error(e,o,r)}})},s.Feed.prototype.__processKMLData=function(e,t){"xml"==t.format&&($(e).find("kml").length?this.__parseKMLData(e,t):a("feed not kml"))},s.Feed.prototype.__parseKMLData=function(e,t){const o=this;if("xml"==t.format){const r=$(e).find("Document"),n=[];let s=null;r.find("Placemark").each((function(){const e=$(this).find("ExtendedData")||$(this);s||(s=[],e.find("Data").each((function(){s.push($(this).attr("name"))})),$(this).find("Point").find("coordinates")&&s.push("KML.Point"),n.push(s));const t=[];e.find("Data").each((function(){t.push($(this).find("value").text())})),$(this).find("Point").find("coordinates")&&t.push($(this).find("Point").find("coordinates").text()),n.push(t)})),o.__createDataTableObject(n,"kml",t)}},s.Feed.prototype.__processGMLData=function(e,t){"xml"==t.format&&("string"==typeof e&&(parser=new DOMParser,e=parser.parseFromString(e,"text/xml")),$(e).find("wfs\\:FeatureCollection, gml\\:FeatureCollection, FeatureCollection").length?this.__parseGMLData(e,t):a("feed not gml"))},s.Feed.prototype.__parseGMLData=function(e,t){const o=this;if("xml"==t.format){const r=$(e).find("wfs\\:FeatureCollection, FeatureCollection").first();if(0===r.length)return void a("No FeatureCollection found in GML data");const n=[];let s=null;r.find("wfs\\:member, gml\\:featureMember, featureMember, gml\\:featureMembers, featureMembers").each((function(){const e=$(this).find("gml\\:*, *").first();if(0===e.length)return;s||(s=[],e.find("gml\\:*, *").each((function(){const e=$(this).prop("tagName");e&&!e.match(/^(gml:)?(boundedBy|location|pos|coordinates|geometry|geometryProperty)$/i)&&s.push(e.replace(/^gml:/,""))})),s.push("GML.Geometry"),n.push(s));const t=[];e.find("gml\\:*, *").each((function(){const e=$(this).prop("tagName");e&&!e.match(/^(gml:)?(boundedBy|location|pos|coordinates|geometry|geometryProperty)$/i)&&t.push($(this).text())}));const o=e.find("gml\\:Polygon").first();if(o.length>0){let e='{"type":"Polygon","coordinates":[[',n=o.text().split(" "),s=0;for(var r=0;r<n.length;r++)if(Number(n[r])&&!isNaN(Number(n[r]))){s=r;break}if(s<n.length-1)for(r=s;r<n.length-1;r+=2)n[r]&&n[r+1]&&!isNaN(Number(n[r]))&&!isNaN(Number(n[r+1]))&&(e+=(r>s?",":"")+"["+n[r+1]+","+n[r]+"]");e+="]]}",t.push(e)}else t.push("");n.push(t)})),o.__createDataTableObject(n,"gml",t)}},s.Feed.prototype.__doJSONImport=function(e,t){const o=this;$.get(e,(function(e){o.__processJsonData(e,t)})).fail((function(e){void 0!==t&&t.error&&t.error(e)}))},s.Feed.prototype.__doJSONLinesImport=function(e,t){_LOG("__doJSONLinesImport: "+e);const o=this;$.ajax({type:"GET",url:e,cache:t.cache,dataType:"text",success:function(e){o.__processJSONLinesData(e,t)},error:function(o,r,n){void 0!==t&&t.error&&t.error('"'+e+'" '+n)}})},__getNestedPaths=function(e,t=""){const o=[];if("object"!=typeof e||null===e||Array.isArray(e))Array.isArray(e)?e.forEach(((e,r)=>{const n=t?`${t}.${r}`:String(r);o.push(...__getNestedPaths(e,n))})):o.push(t);else for(const r in e)if(Object.prototype.hasOwnProperty.call(e,r)){const n=e[r],s=t?`${t}.${r}`:r;o.push(...__getNestedPaths(n,s))}return o},__extractValuesRecursive=function(e,t){let r=[];if(null==e)r.push("null");else if("object"!=typeof t||null===t||Array.isArray(t))if(Array.isArray(t))for(let n=0;n<t.length;n++){const s=n<e.length?e[n]:o;r=r.concat(__extractValuesRecursive(s,t[n]))}else r.push(e);else for(const n in t)if(Object.prototype.hasOwnProperty.call(t,n)){const s=Object.prototype.hasOwnProperty.call(e,n)?e[n]:o;r=r.concat(__extractValuesRecursive(s,t[n]))}return r},s.Feed.prototype.__processJsonData=function(e,t){const o=()=>{if("string"!=typeof e)return!1;const o=e.split(/\r?\n/).filter((e=>e.trim().length));if(o.length<2)return!1;const r=Math.min(o.length,5);for(let e=0;e<r;e++){const t=o[e].trim();try{JSON.parse(t)}catch(e){return!1}}return this.__processJSONLinesData(e,t),!0};let r=null;if("string"==typeof e)try{r=JSON.parse(e)}catch(e){if(o())return;return void this.__createDataTableObject([],"json",t)}else r=e;this.data=r;let n=[],s=[];if(r&&r.data&&r.data.columns&&r.data.rows){const e=r.data.columns,t=r.data.rows;for(let t=0,o=e.length;t<o;t++)s.push(e[t]);n.push(s);for(let e=0,o=t.length;e<o;e++){s=[];for(let o=0,r=t[0].length;o<r;o++)s.push(t[e][o]);n.push(s)}}else{if(r&&r.data&&(r=r.data),!Array.isArray(r)){__findAllArraysInJson=function(e){const t=[];return function e(o){if(Array.isArray(o))t.push(o);else if("object"==typeof o&&null!==o)for(const t in o)o.hasOwnProperty(t)&&e(o[t])}(e),t},r=__findAllArraysInJson(r)[0]}if(!r){let o=[];o.push(["unknown type"]);const r=e.split("\n");for(let e=0,t=r.length;e<t;e++)o.push([r[e]]);return void this.__createDataTableObject(o,"json",t)}n.push(__getNestedPaths(r[0]));for(let e=0;e<r.length;e++)n.push(__extractValuesRecursive(r[e],r[0]))}this.__createDataTableObject(n,"json",t)},s.Feed.prototype.__processJSONLinesData=function(e,t){_LOG("__processJSONLinesData - start");let o=[];const r=[];if(Array.isArray(e))o=e;else if("string"==typeof e){const t=e.split(/\r?\n/);for(let e=0;e<t.length;e++){const n=t[e].trim();if(n)try{const e=JSON.parse(n);o.push(e)}catch(t){r.push({lineNumber:e+1,error:t.message,line:n})}}}else e&&"object"==typeof e&&(o=Array.isArray(e.data)?e.data:[e]);if(r.length,!o.length)return t&&t.error&&t.error("JSONL parsing error: no valid records found"),void this.__createDataTableObject([],"jsonl",t);const n=[],s={},i=function(e){null!=e&&(Object.prototype.hasOwnProperty.call(s,e)||(s[e]=n.length,n.push(e)))},a=o.map((e=>null==e?{}:Array.isArray(e)?{value:JSON.stringify(e)}:"object"==typeof e?e:{value:e}));a.forEach((e=>{for(const t in e)Object.prototype.hasOwnProperty.call(e,t)&&i(t)})),n.length||n.push("value");const l=[n];a.forEach((e=>{const t=n.map((t=>(e=>{if(null==e)return"";if("object"==typeof e)try{return JSON.stringify(e)}catch(e){return""}return e})(Object.prototype.hasOwnProperty.call(e,t)?e[t]:"")));l.push(t)})),t&&t.callback?t.callback(l,t):this.__createDataTableObject(l,"jsonl",t)},s.Feed.prototype.__doGeoJSONImport=function(e,t){const o=this;$.get(e,(function(e){o.__processGeoJsonData(e,t)})).fail((function(e){void 0!==t&&t.error&&t.error(e)}))},s.Feed.prototype.__processGeoJsonData=function(e,t){let r=null;if("string"==typeof e)try{r=JSON.parse(e)}catch(e){return void this.__createDataTableObject([],"json",t)}else r=e;this.data=r;const n=[],s={};if(r&&r.features&&r.features.length){for(const e of r.features)if(e.properties)for(const t in e.properties)s[t]=!0;const e=Object.keys(s);e.push("geometry"),n.push(e);for(const t of r.features){const r=[],s=t.properties||{};for(let t=0;t<e.length-1;t++){const n=s[e[t]];"object"==typeof n?r.push(JSON.stringify(n)):r.push(n!==o?n:"")}r.push(JSON.stringify(t.geometry)),n.push(r)}}this.__createDataTableObject(n,"json",t)},s.Feed.prototype.__processGeoJsonData_expandProperty=function(e,t){let o=null;if("string"==typeof e)try{o=JSON.parse(e)}catch(e){this.__createDataTableObject([],"json",t)}else o=e;this.data=o;let r=[],n=[];const s=[];if(o&&o.features&&o.features.length){for(let e=0;e<o.features.length;e++)for(const t in o.features[e].properties)if("string"==typeof o.features[e].properties[t]||"number"==typeof o.features[e].properties[t])s[t]=!0;else for(const r in o.features[e].properties[t])s[t+"."+r]=!0;for(const e in s)n.push(e);n.push("geometry"),r.push(n);for(let e=0;e<o.features.length;e++){n=[];for(let t=0;t<r[0].length-1;t++){const s=r[0][t].split(".");s.length>=2?n.push(o.features[e].properties[s[0]][s[1]]||""):n.push(o.features[e].properties[r[0][t]]||"")}n.push(JSON.stringify(o.features[e].geometry)),r.push(n)}}this.__createDataTableObject(r,"json",t)},s.Feed.prototype.__doTopoJSONImport=function(e,t){const o=this;$.get(e,(function(e){o.__processTopoJsonData(e,t)})).fail((function(e){void 0!==t&&t.error&&t.error(e)}))},s.Feed.prototype.__processTopoJsonData=function(e,t){if("undefined"==typeof topojson)return void a("'"+t.type+"' parser not loaded !");let o=null;if("string"==typeof e)try{o=JSON.parse(e)}catch(e){this.__createDataTableObject([],"json",t)}else o=e;this.data=o;let r=null;if(t.options&&t.options.name&&o.objects[t.options.name])r=topojson.feature(o,o.objects[t.options.name]);else for(var n in o.objects){r=topojson.feature(o,o.objects[n]);break}for(const e in r.features)r.features[e].properties.id=r.features[e].id;this.__processGeoJsonData(r,t)},s.Feed.prototype.__doParquetImport=function(e,t){_LOG("__doParquetImport: "+e);const o=this;_LOG("Attempting to load parquet file using Fetch API..."),fetch(e,{method:"GET",cache:t.cache?"default":"no-cache"}).then((e=>{if(_LOG("Fetch response received, status: "+e.status),_LOG("Response headers: "+JSON.stringify([...e.headers.entries()])),!e.ok)throw new Error(`HTTP ${e.status}: ${e.statusText}`);return e.arrayBuffer()})).then((e=>{_LOG("Successfully loaded parquet as ArrayBuffer: "+e.byteLength+" bytes");const r=new Uint8Array(e);if(r.length>=4){const n=String.fromCharCode(...r.slice(0,4));_LOG("Magic number: "+n),"PAR1"===n?(_LOG("‚úÖ SUCCESS: Valid parquet file detected!"),o.__processParquetData(e,t)):(_LOG("‚ö†Ô∏è Warning: Magic number is not PAR1: "+n),_LOG("First 16 bytes: "+Array.from(r.slice(0,16)).map((e=>e.toString(16).padStart(2,"0"))).join(" ")),_LOG("Attempting to process anyway..."),o.__processParquetData(e,t))}else _LOG("‚ö†Ô∏è Warning: Response too short to check magic number"),o.__processParquetData(e,t)})).catch((r=>{_LOG("Fetch failed: "+r.message),_LOG("Falling back to XMLHttpRequest..."),o.__loadParquetWithXHR(e,t)}))},s.Feed.prototype.__loadParquetWithXHR=function(e,t){const o=this;_LOG("Loading parquet with XMLHttpRequest...");const r=new XMLHttpRequest;r.open("GET",e,!0),r.responseType="arraybuffer",r.onload=function(){if(200===r.status){const e=r.response;_LOG("XHR successful: "+e.byteLength+" bytes");const n=new Uint8Array(e);if(n.length>=4){const r=String.fromCharCode(...n.slice(0,4));_LOG("XHR magic number: "+r),"PAR1"===r?(_LOG("‚úÖ SUCCESS: Valid parquet file via XHR!"),o.__processParquetData(e,t)):(_LOG("‚ö†Ô∏è Warning: XHR magic number is not PAR1: "+r),_LOG("First 16 bytes: "+Array.from(n.slice(0,16)).map((e=>e.toString(16).padStart(2,"0"))).join(" ")),_LOG("Attempting to process anyway..."),o.__processParquetData(e,t))}else _LOG("‚ö†Ô∏è Warning: XHR response too short to check magic number"),o.__processParquetData(e,t)}else _LOG("XHR failed with status: "+r.status+" "+r.statusText),void 0!==t&&t.error?t.error("XHR failed: "+r.status+" "+r.statusText):a("XHR failed: "+r.status+" "+r.statusText)},r.onerror=function(){_LOG("XHR network error"),void 0!==t&&t.error?t.error("XHR network error"):a("XHR network error")},r.send()},s.Feed.prototype.__checkGeoParquetMetadataWithDuckDB=function(t,o,r){try{const r=t.slice(),n="temp_parquet_"+Date.now()+".parquet";e.duckdb.db.registerFileBuffer(n,new Uint8Array(r)).then((function(){const t=`\n                        SELECT * FROM read_parquet('${n}') LIMIT 1\n                    `;return e.duckdb.conn.query(t)})).then((function(e){let t,r=!1;if("function"==typeof e.toArray)t=e.toArray();else if("function"==typeof e.fetchAll)t=e.fetchAll();else if(Array.isArray(e))t=e;else{if(!e.data||!Array.isArray(e.data))return void o(!1);t=e.data}if(t&&t.length>0){const e=t[0],o=Object.keys(e),n=["geometry","geom","the_geom","wkb_geometry","shape"];for(const e of o){const t=e.toLowerCase();if(n.includes(t)){r=!0;break}}for(const e of o){const t=e.toLowerCase();if(t.includes("wkb")||t.includes("geojson")||t.includes("wkt")||t.includes("coordinates")){r=!0;break}}}o(r)})).catch((function(e){o(!1)})).finally((function(){try{e.duckdb.db.dropFile(n)}catch(e){}}))}catch(e){r(e)}},s.Feed.prototype.__detectColumnTypes=function(e){if(!e||!e.fields)return null;return e.fields.map((e=>{const t=e.type.toString().toLowerCase(),o=e.name.toLowerCase();let r;return r=t.includes("geometry")||t.includes("wkb")||t.includes("wkt")||t.includes("blob")||t.includes("binary")||"geometry"===o||"geom"===o||"wkb_geometry"===o||"wkt_geometry"===o||o.includes("shape")?"geometry":t.includes("list")||t.includes("array")?"array":t.includes("utf8")||t.includes("string")||t.includes("varchar")?"string":t.includes("int")||t.includes("float")||t.includes("double")||t.includes("decimal")?"number":t.includes("bool")?"boolean":t.includes("date")||t.includes("timestamp")?"date":"other","geometry"===r?s.log(`üó∫Ô∏è Detected geometry column: "${e.name}" (type: ${t})`):"array"===r&&s.log(`üìã Detected array column: "${e.name}" (type: ${t})`),r}))},s.Feed.prototype.__convertGeometryToGeoJSON=function(e){if(!e)return"";try{if(e instanceof ArrayBuffer||ArrayBuffer.isView(e)){const t=e instanceof Uint8Array?e:new Uint8Array(e.buffer||e,e.byteOffset||0,e.byteLength||e.length||0);return this.__parseWKB(t)}if(Array.isArray(e)&&e.length&&"number"==typeof e[0]){const t=Uint8Array.from(e);return this.__parseWKB(t)}if("string"==typeof e)return e.match(/^(POINT|LINESTRING|POLYGON|MULTIPOINT|MULTILINESTRING|MULTIPOLYGON|GEOMETRYCOLLECTION)\s*\(/i)?this.__wktToGeoJSON(e):(e.trim().startsWith("{"),e);if("object"==typeof e){const t=Object.keys(e);if(t.length&&t.every((e=>/^\d+$/.test(e)))){const o=new Uint8Array(t.length);return t.sort(((e,t)=>e-t)).forEach(((t,r)=>{o[r]=e[t]})),this.__parseWKB(o)}return JSON.stringify(e)}return String(e)}catch(t){try{return JSON.stringify(e)}catch(t){return String(e||"")}}},s.Feed.prototype.__isNumericKeyObject=function(e){if(!e||"object"!=typeof e||Array.isArray(e))return!1;const t=Object.keys(e);return!!t.length&&(!(t.length<4)&&t.every((e=>/^\d+$/.test(e))))},s.Feed.prototype.__parseWKB=function(e){try{if(e.length<5)return"";const t=new DataView(e.buffer,e.byteOffset,e.byteLength),o=this.__readWKBGeometry(t,0);if(o&&o.geometry)return JSON.stringify(o.geometry)}catch(e){}const t=Array.from(e).map((e=>e.toString(16).padStart(2,"0"))).join("");return JSON.stringify({type:"WKB",wkb:t})},s.Feed.prototype.__readWKBGeometry=function(e,t){if(t+5>e.byteLength)throw new Error("WKB buffer too small");const o=1===e.getUint8(t);let r=t+1,n=e.getUint32(r,o);r+=4;const s=Math.floor(n/1e3),i=1===s||3===s,a=2===s||3===s,l=()=>{const t=[];return t.push(e.getFloat64(r,o)),r+=8,t.push(e.getFloat64(r,o)),r+=8,i&&(t.push(e.getFloat64(r,o)),r+=8),a&&(t.push(e.getFloat64(r,o)),r+=8),t};let c;switch(n%1e3){case 1:c={type:"Point",coordinates:l()};break;case 2:c=(()=>{const t=e.getUint32(r,o);r+=4;const n=[];for(let e=0;e<t;e++)n.push(l());return{type:"LineString",coordinates:n}})();break;case 3:c=(()=>{const t=e.getUint32(r,o);r+=4;const n=[];for(let s=0;s<t;s++){const t=e.getUint32(r,o);r+=4;const s=[];for(let e=0;e<t;e++)s.push(l());n.push(s)}return{type:"Polygon",coordinates:n}})();break;case 4:{const t=e.getUint32(r,o);r+=4;const n=[];for(let o=0;o<t;o++){const t=this.__readWKBGeometry(e,r);r=t.offset,"Point"===t.geometry.type?n.push(t.geometry.coordinates):n.push(t.geometry)}c={type:"MultiPoint",coordinates:n};break}case 5:{const t=e.getUint32(r,o);r+=4;const n=[];for(let o=0;o<t;o++){const t=this.__readWKBGeometry(e,r);r=t.offset,"LineString"===t.geometry.type?n.push(t.geometry.coordinates):n.push(t.geometry)}c={type:"MultiLineString",coordinates:n};break}case 6:{const t=e.getUint32(r,o);r+=4;const n=[];for(let o=0;o<t;o++){const t=this.__readWKBGeometry(e,r);r=t.offset,"Polygon"===t.geometry.type?n.push(t.geometry.coordinates):n.push(t.geometry)}c={type:"MultiPolygon",coordinates:n};break}case 7:{const t=e.getUint32(r,o);r+=4;const n=[];for(let o=0;o<t;o++){const t=this.__readWKBGeometry(e,r);r=t.offset,n.push(t.geometry)}c={type:"GeometryCollection",geometries:n};break}default:{const o=e.byteLength-t,s=new Uint8Array(e.buffer,e.byteOffset+t,o);c={type:"WKB",wkb:Array.from(s).map((e=>e.toString(16).padStart(2,"0"))).join(""),geomType:n},r=e.byteLength;break}}return{geometry:c,offset:r}},s.Feed.prototype.__wktToGeoJSON=function(e){try{const t=e.match(/POINT\s*\(\s*([^\s]+)\s+([^\s]+)\s*\)/i);return t?JSON.stringify({type:"Point",coordinates:[parseFloat(t[1]),parseFloat(t[2])]}):JSON.stringify({type:"WKT",wkt:e})}catch(t){return e}},s.Feed.prototype.__convertValue=function(e,t){if(null==e)return"";if(t)switch(t){case"geometry":return this.__convertGeometryToGeoJSON(e);case"array":if(Array.isArray(e))return JSON.stringify(e);if(e&&"object"==typeof e&&"function"==typeof e.toArray)return JSON.stringify(e.toArray());if(e&&"object"==typeof e)try{return JSON.stringify(Array.from(e))}catch(t){return JSON.stringify(e)}return String(e);case"string":return e;case"number":case"boolean":return String(e);case"date":return e instanceof Date?e.toISOString():String(e);default:return"string"==typeof e?e:"object"==typeof e?JSON.stringify(e):String(e)}else{if("string"==typeof e)return e;if("number"==typeof e||"boolean"==typeof e)return String(e);if(e instanceof Date)return e.toISOString();if(Array.isArray(e)){if(e.length&&e.every((e=>"number"==typeof e)))try{return this.__convertGeometryToGeoJSON(Uint8Array.from(e))}catch(e){}return JSON.stringify(e)}if(e&&"object"==typeof e&&"function"==typeof e.toArray)try{return JSON.stringify(e.toArray())}catch(t){return JSON.stringify(e)}else{if(e&&"object"==typeof e){if(this.__isNumericKeyObject(e))try{const t=Object.keys(e).map(Number).sort(((e,t)=>e-t)),o=new Uint8Array(t.length);return t.forEach(((t,r)=>{o[r]=e[t]})),this.__convertGeometryToGeoJSON(o)}catch(e){}return JSON.stringify(e)}try{return JSON.stringify(e)}catch(t){return String(e||"")}}}},s.Feed.prototype.__processRow=function(e,t,o,r,n){const s=new Array(t.length);for(let i=0;i<t.length;i++){let a;a=r?e[i]:n?e[t[i]]:e,s[i]=this.__convertValue(a,o?o[i]:null)}return s},s.Feed.prototype.__scheduleIdleWork=function(e,t){return new Promise(((o,r)=>{"function"==typeof requestIdleCallback?requestIdleCallback((t=>{try{e(t),o()}catch(e){r(e)}}),{timeout:t||1e3}):setTimeout((()=>{try{e(null),o()}catch(e){r(e)}}),0)}))},s.Feed.prototype.__createParquetWorker=function(){const e=new Blob(["\n            // Web Worker for processing parquet data\n            self.onmessage = function(e) {\n                const { rows, columns, isArrayFormat, isObjectFormat, batchSize } = e.data;\n                \n                try {\n                    const cellsPerRow = columns.length;\n                    const totalRows = rows.length;\n                    let processedRows = 0;\n                    \n                    // Process data in batches\n                    for (let batchStart = 0; batchStart < totalRows; batchStart += batchSize) {\n                        const batchEnd = Math.min(batchStart + batchSize, totalRows);\n                        const batchData = [];\n                        \n                        // Process batch\n                        for (let i = batchStart; i < batchEnd; i++) {\n                            const row = new Array(cellsPerRow);\n                            \n                            for (let j = 0; j < cellsPerRow; j++) {\n                                let value;\n                                \n                                // Get value based on pre-detected format\n                                if (isArrayFormat) {\n                                    value = rows[i][j];\n                                } else if (isObjectFormat) {\n                                    value = rows[i][columns[j]];\n                                } else {\n                                    value = rows[i];\n                                }\n                                \n                                // Optimized type handling\n                                if (value == null) {\n                                    row[j] = '';\n                                } else if (typeof value === 'string') {\n                                    row[j] = value;\n                                } else if (typeof value === 'number' || typeof value === 'boolean') {\n                                    row[j] = String(value);\n                                } else if (value instanceof Date) {\n                                    row[j] = value.toISOString();\n                                } else {\n                                    try {\n                                        row[j] = JSON.stringify(value);\n                                    } catch (e) {\n                                        row[j] = String(value);\n                                    }\n                                }\n                            }\n                            batchData.push(row);\n                        }\n                        \n                        processedRows = batchEnd;\n                        \n                        // Send batch back to main thread\n                        self.postMessage({\n                            type: 'batch',\n                            data: batchData,\n                            processed: processedRows,\n                            total: totalRows,\n                            progress: Math.round((processedRows / totalRows) * 100)\n                        });\n                        \n                        // Clear batch to free memory\n                        batchData.length = 0;\n                    }\n                    \n                    // Send completion message\n                    self.postMessage({\n                        type: 'complete',\n                        processed: processedRows,\n                        total: totalRows\n                    });\n                    \n                } catch (error) {\n                    self.postMessage({\n                        type: 'error',\n                        error: error.message || String(error)\n                    });\n                }\n            };\n        "],{type:"application/javascript"}),t=URL.createObjectURL(e);return new Worker(t)},s.Feed.prototype.__processStreamingDataset=function(t,o,r,n,i){const a=this;if(!("undefined"!=typeof Worker))return a.__processStreamingDatasetFallback(t,o,r,n,i);const l=t.length>0&&Array.isArray(t[0]),c=t.length>0&&"object"==typeof t[0]&&null!==t[0]&&!Array.isArray(t[0]),u=new Array(t.length+1);u[0]=o;const d=o.length,f=(t.length,s.getOptimizedBatchSize("worker",t.length,d));if(t.length*d*50/1048576>500)return a.__processStreamingDatasetFallback(t,o,r,n,i);return(async()=>{const e=[],n=s.getOptimizedBatchSize("extract",t.length,d);for(let s=0;s<t.length;s+=n){const i=Math.min(s+n,t.length);await a.__scheduleIdleWork((n=>{for(let n=s;n<i;n++)if(l){const s=new Array(o.length);for(let e=0;e<o.length;e++){const o=t[n][e];s[e]=a.__convertValue(o,r?r[e]:null)}e.push(s)}else if(c){const s={};for(let e=0;e<o.length;e++){const i=o[e],l=t[n][i];s[i]=a.__convertValue(l,r?r[e]:null)}e.push(s)}else e.push(a.__convertValue(t[n],r?r[0]:null));i%5e5==0||t.length}),1e3)}return e})().then((function(s){return new Promise(((d,h)=>{try{const t=a.__createParquetWorker();let r=null;t.onmessage=function(o){const{type:s,data:l,processed:c,total:f,progress:p,error:g}=o.data;if("batch"===s){const e=c-l.length+1;for(let t=0;t<l.length;t++)u[e+t]=l[t];c%2e6!=0&&c!==f||performance.memory&&(Math.round(performance.memory.usedJSHeapSize/1024/1024),Math.round(performance.memory.totalJSHeapSize/1024/1024))}else if("complete"===s){t.terminate(),r&&URL.revokeObjectURL(r);try{e.duckdb.db.dropFile(n)}catch(e){}_LOG("Worker converted: "+u.length+" total rows (including header)"),a.__createDataTableObject(u,"parquet",i),d()}else if("error"===s){t.terminate(),r&&URL.revokeObjectURL(r);try{e.duckdb.db.dropFile(n)}catch(e){}h(new Error(g))}},t.onerror=function(e){t.terminate(),r&&URL.revokeObjectURL(r),h(e)},t.postMessage({rows:s,columns:o,isArrayFormat:l,isObjectFormat:c,batchSize:f})}catch(e){return a.__processStreamingDatasetFallback(t,o,r,n,i)}}))})).catch((function(t){try{e.duckdb.db.dropFile(n)}catch(e){}i&&"function"==typeof i.error&&i.error(t)}))},s.Feed.prototype.__processStreamingDatasetFallback=function(t,o,r,n,i){const a=this,l=t.length>0&&Array.isArray(t[0]),c=t.length>0&&"object"==typeof t[0]&&null!==t[0]&&!Array.isArray(t[0]),u=new Array(t.length+1);u[0]=o;const d=o.length,f=t.length*d,h=1e6;s.log(`Processing ${t.length.toLocaleString()} rows (${f.toLocaleString()} cells) in batches of ${h.toLocaleString()} rows`),r&&s.log("‚ö° Schema-based optimization active for faster processing");const p=async(e,n)=>a.__scheduleIdleWork((s=>{for(let s=e;s<n;s++)u[s+1]=a.__processRow(t[s],o,r,l,c)}),1e3);return(async()=>{const e=Date.now();let o=e;for(let r=0;r<t.length;r+=h){const n=Math.min(r+h,t.length);await p(r,n);const i=Date.now(),a=i-o;if(n%5e5==0||n===t.length||a>2e3){const r=((i-e)/1e3).toFixed(1),a=Math.round(n/((i-e)/1e3));let l="";if(performance.memory){l=` | Memory: ${Math.round(performance.memory.usedJSHeapSize/1024/1024)}MB / ${Math.round(performance.memory.totalJSHeapSize/1024/1024)}MB`}s.log(` ${n.toLocaleString()} / ${t.length.toLocaleString()} rows (${Math.round(n/t.length*100)}%) | ${a.toLocaleString()} rows/sec | ${r}s${l}`),o=i}}})().then((function(){_LOG("Fallback converted: "+u.length+" total rows (including header)");try{e.duckdb.db.dropFile(n)}catch(e){}a.__createDataTableObject(u,"parquet",i)})).catch((function(t){try{e.duckdb.db.dropFile(n)}catch(e){}i&&"function"==typeof i.error&&i.error(t)}))},s.Feed.prototype.__processParquetData=function(t,o){const r=this;_LOG("Processing parquet data with DuckDB WASM..."),void 0!==e.duckdb&&e.duckdbLoaded&&e.duckdb.conn?e.duckdb.conn.query("SELECT 1 as test").then((e=>{r.__processParquetWithDuckDB(t,o)})).catch((e=>{r.__cleanupDuckDB(),r.__loadDuckDBAndProcess(t,o)})):r.__loadDuckDBAndProcess(t,o)},s.Feed.prototype.__processParquetWithDuckDB=function(e,t){const o=this;_LOG("Detecting if parquet file is GeoParquet..."),o.__checkGeoParquetMetadataWithDuckDB(e,(function(r){r?(_LOG("‚úÖ GeoParquet detected! Switching to GeoParquet processing..."),"function"==typeof o.__processGeoParquetData?o.__processGeoParquetData(e,t):(_LOG("‚ö†Ô∏è GeoParquet processing function not found, falling back to regular parquet processing"),o.__processWithDuckDB(e,t))):(_LOG("‚úÖ Regular parquet file detected, proceeding with standard processing..."),o.__processWithDuckDB(e,t))}),(function(r){_LOG("‚ö†Ô∏è Error detecting GeoParquet, falling back to regular parquet processing: "+r),o.__processWithDuckDB(e,t)}))},s.Feed.prototype.__loadDuckDBAndProcess=function(o,r){const n=this;_LOG("Loading DuckDB WASM module dynamically...");const s=t.createElement("script");s.type="module",s.textContent='\n            // Try to load DuckDB WASM from CDN\n            let duckdb;\n            try {\n                // Try jsDelivr first (most reliable for DuckDB WASM)\n                duckdb = await import("https://cdn.jsdelivr.net/npm/@duckdb/duckdb-wasm@latest/+esm");\n                console.log("‚úÖ DuckDB loaded from jsDelivr");\n            } catch (e1) {\n                try {\n                    // Fallback to ESM.sh\n                    duckdb = await import("https://esm.sh/@duckdb/duckdb-wasm@1.30.0");\n                    console.log("‚úÖ DuckDB loaded from ESM.sh");\n                } catch (e2) {\n                    try {\n                        // Fallback to unpkg\n                        duckdb = await import("https://unpkg.com/@duckdb/duckdb-wasm@1.30.0");\n                        console.log("‚úÖ DuckDB loaded from unpkg");\n                    } catch (e3) {\n                        throw new Error("Failed to load DuckDB from any CDN: " + e3.message);\n                    }\n                }\n            }\n            \n            console.log("DuckDB WASM module imported:", duckdb);\n            console.log("Available DuckDB methods:", Object.keys(duckdb));\n            \n            // Initialize DuckDB\n            try {\n                console.log(\'üîß Selecting bundle from jsDelivr CDN...\');\n                const JSDELIVR_BUNDLES = duckdb.getJsDelivrBundles();\n                \n                // Force MVP bundle (single-threaded) to avoid pthread worker issues\n                // The "eh" bundle uses pthread which can hit browser worker limits\n                console.log(\'üéØ Forcing MVP bundle (single-threaded) to avoid resource limits...\');\n                const bundle = JSDELIVR_BUNDLES.mvp;\n                console.log(\'‚úÖ Using MVP bundle:\', bundle);\n                \n                console.log("üë∑ Creating worker from bundle...");\n                \n                let worker;\n                try {\n                    // Create worker using blob URL approach to avoid CORS issues\n                    const worker_url = URL.createObjectURL(\n                        new Blob([`importScripts("${bundle.mainWorker}");`], { type: \'text/javascript\' })\n                    );\n                    worker = new Worker(worker_url);\n                    console.log("‚úÖ Worker created successfully");\n                    \n                    // Revoke the blob URL to free memory\n                    URL.revokeObjectURL(worker_url);\n                } catch (workerError) {\n                    console.error("‚ùå Failed to create Web Worker:", workerError);\n                    throw new Error("Worker creation failed: " + workerError.message + ". This may be due to browser resource limits. Try refreshing the page.");\n                }\n                \n                const logger = new duckdb.ConsoleLogger();\n                const db = new duckdb.AsyncDuckDB(logger, worker);\n                \n                console.log("üöÄ Instantiating DuckDB with WASM module...");\n                // MVP bundle is single-threaded, so we don\'t pass pthreadWorker\n                await db.instantiate(bundle.mainModule);\n                console.log("‚úÖ DuckDB WASM instantiated successfully");\n                \n                // Create connection\n                const conn = await db.connect();\n                \n                console.log("‚úÖ DuckDB WASM initialized successfully");\n                console.log("DuckDB connection object type:", typeof conn);\n                console.log("DuckDB connection methods:", Object.getOwnPropertyNames(conn));\n                console.log("DuckDB connection constructor:", conn.constructor.name);\n                \n                // Store references globally with worker reference for cleanup\n                window.duckdb = {\n                    module: duckdb,\n                    worker: worker,\n                    db: db,\n                    conn: conn\n                };\n                window.duckdbLoaded = true;\n            \n            } catch (error) {\n                console.error("‚ùå Failed to initialize DuckDB WASM:", error);\n                window.duckdbLoadError = error;\n            }\n            ',t.head.appendChild(s);const i=setInterval((function(){e.duckdbLoaded&&e.duckdb?(clearInterval(i),_LOG("DuckDB WASM module loaded successfully"),n.__processParquetWithDuckDB(o,r)):e.duckdbLoadError&&(clearInterval(i),_LOG("Failed to load DuckDB WASM module: "+e.duckdbLoadError),void 0!==r&&r.error?r.error("Failed to load DuckDB WASM module: "+e.duckdbLoadError):a("Failed to load DuckDB WASM module: "+e.duckdbLoadError))}),100);setTimeout((function(){e.duckdbLoaded||e.duckdbLoadError||(clearInterval(i),_LOG("Timeout loading DuckDB WASM module"),void 0!==r&&r.error?r.error("Timeout loading DuckDB WASM module"):a("Timeout loading DuckDB WASM module"))}),15e3)},s.Feed.prototype.__processWithDuckDB=function(t,o){const r=this;try{const n=(t.byteLength/1024/1024).toFixed(2);_LOG("Processing parquet data with DuckDB WASM, buffer size: "+t.byteLength+" bytes ("+n+" MB)"),s.log("ü¶Ü Starting DuckDB parquet processing...");const i=524288e3;if(t.byteLength>i){const e=`‚ö†Ô∏è Large file detected (${n} MB). Processing may fail due to browser memory limits. Consider loading a smaller file or a subset of the data.`;s.log(e)}if(t.byteLength<4)throw new Error("File too small to be a valid parquet file");const l=new Uint8Array(t),c=String.fromCharCode(...l.slice(0,4));if(_LOG("Parquet file magic number: "+c),"PAR1"!==c)throw new Error("File does not appear to be a valid parquet file (missing PAR1 magic number). Magic: "+c);_LOG("Valid parquet file detected, processing with DuckDB WASM...");const u="temp_parquet_"+Date.now()+".parquet",d=new Uint8Array(l);e.duckdb.db.registerFileBuffer(u,d).then((function(){return e.duckdb.conn.query(`SELECT COUNT(*) as count FROM read_parquet('${u}')`)})).then((async function(t){const o=t.toArray()[0].count,r="bigint"==typeof o?Number(o):o;s.log(`File has ${r.toLocaleString()} rows - loading all data in batches...`);const n=`SELECT * FROM read_parquet('${u}') LIMIT 1`,i=(await e.duckdb.conn.query(n)).schema,a=i.names?i.names.length:0,l=s.getOptimizedBatchSize("parquet",r,a),c=Math.ceil(r/l);let d=[];for(let t=0;t<c;t++){const o=t*l,n=r-o,i=Math.min(l,n);s.log(`Loading batch ${t+1}/${c}... (${Math.round(t/c*100)}%)`);const a=`SELECT * FROM read_parquet('${u}') LIMIT ${i} OFFSET ${o}`,f=(await e.duckdb.conn.query(a)).toArray();d=d.concat(f)}return s.log(`‚úÖ All ${d.length.toLocaleString()} rows loaded successfully!`),{schema:i,toArray:function(){return d}}})).then((async function(e){if(_LOG("DuckDB query result type: "+typeof e),!e)throw new Error("DuckDB query returned null/undefined");let t,n;if("function"==typeof e.toArray)t=e.toArray();else if("function"==typeof e.fetchAll)t=e.fetchAll();else if(Array.isArray(e))t=e;else{if(!e.data||!Array.isArray(e.data))throw new Error("Cannot convert DuckDB result to array. Available methods: "+Object.getOwnPropertyNames(e).join(", "));t=e.data}if(0===t.length)throw new Error("No rows found in parquet file");let i=null;if(e.schema&&e.schema.fields)n=e.schema.fields.map((e=>e.name)),i=r.__detectColumnTypes(e.schema),i&&_LOG("Schema-based optimization enabled - detected column types: "+i.join(", "));else if(e.columns)n=e.columns;else{if(!(t.length>0&&"object"==typeof t[0]))throw new Error("Cannot determine column names from DuckDB result");n=Object.keys(t[0])}if(_LOG("Extracted columns: "+n.join(", ")),0===n.length)throw new Error("No columns found in parquet file");const a=n.filter((e=>{const t=(e||"").toLowerCase();return"geometry"===t||"geom"===t||"wkb_geometry"===t||"shape"===t||t.includes("geom")}));a.length&&(i||(i=n.map((()=>"other"))),a.forEach((e=>{const t=n.indexOf(e);-1!==t&&(i[t]="geometry")})));const l=[];if(t.length>1e7)throw new Error(`Dataset too large (${t.length} rows). Maximum supported: 10,000,000 rows. Consider using a smaller LIMIT in your query.`);if(t.length>5e5&&s.log(`‚ö†Ô∏è Processing very large dataset (${t.length} rows). This may take a while and use significant memory.`),t.length>1e5)return s.log("Large dataset detected, using streaming processing..."),r.__processStreamingDataset(t,n,i,u,o);if(t.length>5e4){const e=t.length>0&&Array.isArray(t[0]),o=t.length>0&&"object"==typeof t[0]&&null!==t[0]&&!Array.isArray(t[0]),a=n.length,c=(t.length,Math.min(2e6,Math.max(1e5,Math.floor(1e7/a))));i&&s.log("‚ö° Schema-based optimization active for medium dataset");try{const a=async(s,a)=>r.__scheduleIdleWork((c=>{for(let c=s;c<a;c++)l.push(r.__processRow(t[c],n,i,e,o))}),1e3),u=Date.now();let d=u;for(let e=0;e<t.length;e+=c){const o=Math.min(e+c,t.length);await a(e,o);const r=Date.now(),n=r-d;if(o%5e5==0||o===t.length||n>2e3){const e=((r-u)/1e3).toFixed(1),n=Math.round(o/((r-u)/1e3));let i="";if(performance.memory){const e=Math.round(performance.memory.usedJSHeapSize/1024/1024);i=` | Memory: ${e}MB / ${Math.round(performance.memory.totalJSHeapSize/1024/1024)}MB`}s.log(`Processing: ${o.toLocaleString()} / ${t.length.toLocaleString()} rows (${Math.round(o/t.length*100)}%) | ${n.toLocaleString()} rows/sec | ${e}s${i}`),d=r}}}catch(e){const o=t.length>0&&Array.isArray(t[0]),a=t.length>0&&"object"==typeof t[0]&&null!==t[0]&&!Array.isArray(t[0]),c=1e4,u=Date.now();let d=u;if(o)for(let e=0;e<t.length;e+=c){const o=Math.min(e+c,t.length);for(let s=e;s<o;s++){const e=new Array(n.length);for(let o=0;o<n.length;o++){const n=t[s][o];e[o]=r.__convertValue(n,i?i[o]:null)}l.push(e)}const a=Date.now(),f=a-d;if(o%5e4==0||o===t.length||f>2e3){const e=((a-u)/1e3).toFixed(1),r=Math.round(o/((a-u)/1e3));let n="";if(performance.memory){n=` | Memory: ${Math.round(performance.memory.usedJSHeapSize/1024/1024)}MB / ${Math.round(performance.memory.totalJSHeapSize/1024/1024)}MB`}s.log(`Fallback: ${o.toLocaleString()} / ${t.length.toLocaleString()} rows (${Math.round(o/t.length*100)}%) | ${r.toLocaleString()} rows/sec | ${e}s${n}`),d=a}}else if(a)for(let e=0;e<t.length;e+=c){const o=Math.min(e+c,t.length);for(let s=e;s<o;s++){const e=new Array(n.length);for(let o=0;o<n.length;o++){const a=t[s][n[o]];e[o]=r.__convertValue(a,i?i[o]:null)}l.push(e)}const a=Date.now(),f=a-d;if(o%5e4==0||o===t.length||f>2e3){const e=((a-u)/1e3).toFixed(1),r=Math.round(o/((a-u)/1e3));let n="";if(performance.memory){n=` | Memory: ${Math.round(performance.memory.usedJSHeapSize/1024/1024)}MB / ${Math.round(performance.memory.totalJSHeapSize/1024/1024)}MB`}s.log(`Fallback: ${o.toLocaleString()} / ${t.length.toLocaleString()} rows (${Math.round(o/t.length*100)}%) | ${r.toLocaleString()} rows/sec | ${e}s${n}`),d=a}}else for(let e=0;e<t.length;e+=c){const o=Math.min(e+c,t.length);for(let s=e;s<o;s++){const e=new Array(n.length);for(let o=0;o<n.length;o++){const n=t[s];e[o]=r.__convertValue(n,i?i[o]:null)}l.push(e)}const a=Date.now(),f=a-d;if(o%5e4==0||o===t.length||f>2e3){const e=((a-u)/1e3).toFixed(1),r=Math.round(o/((a-u)/1e3));let n="";if(performance.memory){n=` | Memory: ${Math.round(performance.memory.usedJSHeapSize/1024/1024)}MB / ${Math.round(performance.memory.totalJSHeapSize/1024/1024)}MB`}s.log(`Fallback: ${o.toLocaleString()} / ${t.length.toLocaleString()} rows (${Math.round(o/t.length*100)}%) | ${r.toLocaleString()} rows/sec | ${e}s${n}`),d=a}}}}else{const e=t.length>0&&Array.isArray(t[0]),o=t.length>0&&"object"==typeof t[0]&&null!==t[0]&&!Array.isArray(t[0]);for(let s=0;s<t.length;s++){const a=new Array(n.length);for(let l=0;l<n.length;l++){let c;c=e?t[s][l]:o?t[s][n[l]]:t[s],a[l]=r.__convertValue(c,i?i[l]:null)}l.push(a)}}_LOG("Converted "+l.length+" rows with "+n.length+" columns");const c=[n];c.push(...l),r.__createDataTableObject(c,"parquet",o)})).catch((function(e){_LOG("Error in DuckDB parquet processing: "+e);let r=e.message;e.message&&e.message.includes("malloc")&&(r=`File is too large to process in browser (requires ${(t.byteLength/1024/1024).toFixed(0)}+ MB of memory). Please try:\n1. Use a smaller file (< 500MB recommended)\n2. Filter the data before loading\n3. Use DuckDB CLI or other tools for large files`,s.log("‚ùå File too large: Browser cannot allocate enough memory")),void 0!==o&&o.error?o.error(r):a(r)})).finally((function(){try{e.duckdb.db.dropFile(u)}catch(e){}}))}catch(e){_LOG("Error in DuckDB parquet processing setup: "+e),void 0!==o&&o.error?o.error("Error setting up DuckDB parquet processing: "+e.message):a("Error setting up DuckDB parquet processing: "+e.message)}},s.Feed.prototype.__processGeoParquetData=function(o,r){const n=this;if(void 0!==e.geoparquet)_LOG("GeoParquet library already loaded, processing data..."),n.__processWithGeoParquet(o,r,e.geoparquet);else{_LOG("Loading GeoParquet library dynamically...");const s=t.createElement("script");s.type="module",s.textContent='\n                import { asyncBufferFromUrl, toGeoJson } from \'https://cdn.jsdelivr.net/npm/geoparquet@0.5.0/+esm\';\n                \n                console.log("GeoParquet module imported");\n                console.log("Available geoparquet methods:", Object.keys({ asyncBufferFromUrl, toGeoJson }));\n                \n                // Make geoparquet available globally\n                window.geoparquet = { asyncBufferFromUrl, toGeoJson };\n                window.geoparquetLoaded = true;\n            ';const i=setInterval((function(){e.geoparquetLoaded&&e.geoparquet&&(clearInterval(i),_LOG("GeoParquet module loaded successfully"),n.__processWithGeoParquet(o,r,e.geoparquet))}),100);setTimeout((function(){e.geoparquetLoaded||(clearInterval(i),_LOG("Failed to load GeoParquet module"),void 0!==r&&r.error?r.error("Failed to load GeoParquet module"):a("Failed to load GeoParquet module"))}),1e4),t.head.appendChild(s)}},s.Feed.prototype.__processWithGeoParquet=function(t,o,r){const n=this;try{if(_LOG("Processing GeoParquet data, buffer size: "+t.byteLength+" bytes"),_LOG("GeoParquet object: "+JSON.stringify(r)),_LOG("Available geoparquet methods: "+Object.keys(r).join(", ")),t.byteLength<4)throw new Error("File too small to be a valid parquet file");const i=new Uint8Array(t),l=String.fromCharCode(...i.slice(0,4));if(_LOG("Parquet file magic number: "+l),"PAR1"!==l)throw new Error("File does not appear to be a valid parquet file (missing PAR1 magic number). Magic: "+l);if(_LOG("Valid parquet file detected, processing with geoparquet..."),"function"!=typeof r.toGeoJson)throw new Error("toGeoJson method not found in geoparquet. Available methods: "+Object.keys(r).join(", "));let c;_LOG("Calling geoparquet.toGeoJson...");try{c=r.toGeoJson({file:t})}catch(r){if(r.message&&(r.message.includes("non-delta field")||r.message.includes("ZSTD")||r.message.includes("unsupported compression")||r.message.toLowerCase().includes("unsupported geometry type")))return r.message.includes("ZSTD")?s.log("‚ö†Ô∏è File uses ZSTD compression - switching to DuckDB..."):r.message.toLowerCase().includes("unsupported geometry type")&&s.log("‚ö†Ô∏è File uses geometry type not supported by GeoParquet library - switching to DuckDB..."),_LOG("GeoParquet library failed with compatibility issue, using DuckDB fallback"),e.duckdb&&e.duckdb.db?n.__processWithDuckDB(t,o):n.__loadDuckDBAndProcess(t,o);throw r}if(_LOG("GeoJSON conversion result type: "+typeof c),_LOG("GeoJSON conversion result: "+JSON.stringify(c)),c&&"function"==typeof c.then)_LOG("GeoJSON conversion is a Promise, waiting for resolution..."),c.then((function(e){try{_LOG("GeoJSON conversion completed successfully"),_LOG("GeoJSON type: "+e.type),_LOG("Number of features: "+(e.features?e.features.length:"unknown")),n.__processGeoJsonData(e,o)}catch(e){throw _LOG("Error processing GeoJSON data: "+e),new Error("Error processing GeoJSON data: "+e)}})).catch((function(r){_LOG("Error in GeoJSON conversion: "+r),_LOG("Error stack: "+r.stack),_LOG("Error message: "+r.message);r.message&&(r.message.includes("non-delta field")||r.message.includes("ZSTD")||r.message.includes("unsupported compression")||r.message.toLowerCase().includes("unsupported geometry type"))?(r.message.includes("ZSTD")?s.log("‚ö†Ô∏è File uses ZSTD compression - switching to DuckDB..."):r.message.toLowerCase().includes("unsupported geometry type")&&s.log("‚ö†Ô∏è File uses geometry type not supported by GeoParquet library - switching to DuckDB..."),_LOG("GeoParquet library failed with compatibility issue, using DuckDB fallback"),e.duckdb&&e.duckdb.db?n.__processWithDuckDB(t,o):n.__loadDuckDBAndProcess(t,o)):void 0!==o&&o.error?o.error("Error converting GeoParquet to GeoJSON: "+r):a("Error converting GeoParquet to GeoJSON: "+r)}));else{if(_LOG("GeoJSON conversion returned directly"),!c)throw new Error("GeoJSON conversion returned null or undefined");_LOG("GeoJSON type: "+c.type),_LOG("Number of features: "+(c.features?c.features.length:"unknown")),this.__processGeoJsonData(c,o)}}catch(e){_LOG("Error processing GeoParquet data: "+e),void 0!==o&&o.error?o.error("Error processing GeoParquet data: "+e):a("Error processing GeoParquet data: "+e)}},s.Feed.prototype.__doGpkgImport=function(e,t){_LOG("__doGpkgImport: "+e);const o=this;_LOG("Attempting to load GeoPackage file using Fetch API..."),fetch(e,{method:"GET",cache:t.cache?"default":"no-cache"}).then((e=>{if(_LOG("Fetch response received, status: "+e.status),!e.ok)throw new Error(`HTTP ${e.status}: ${e.statusText}`);return e.arrayBuffer()})).then((e=>{_LOG("Successfully loaded GeoPackage as ArrayBuffer: "+e.byteLength+" bytes");const r=new Uint8Array(e);if(r.length>=16){const n=String.fromCharCode(...r.slice(0,16));_LOG("Magic string: "+n),n.startsWith("SQLite format 3")?(_LOG("‚úÖ SUCCESS: Valid GeoPackage (SQLite) file detected!"),o.__processGpkgData(e,t)):(_LOG("‚ö†Ô∏è Warning: Magic string is not 'SQLite format 3': "+n),_LOG("First 16 bytes: "+Array.from(r.slice(0,16)).map((e=>e.toString(16).padStart(2,"0"))).join(" ")),_LOG("Attempting to process as GeoPackage anyway..."),o.__processGpkgData(e,t))}else _LOG("‚ö†Ô∏è Warning: Response too short to check magic number"),o.__processGpkgData(e,t)})).catch((r=>{_LOG("Fetch failed: "+r.message),_LOG("Falling back to XMLHttpRequest..."),o.__loadGpkgWithXHR(e,t)}))},s.Feed.prototype.__loadGpkgWithXHR=function(e,t){const o=this;_LOG("Loading GeoPackage with XMLHttpRequest...");const r=new XMLHttpRequest;r.open("GET",e,!0),r.responseType="arraybuffer",r.onload=function(){if(200===r.status){const e=r.response;_LOG("XHR successful: "+e.byteLength+" bytes");const n=new Uint8Array(e);if(n.length>=16){const r=String.fromCharCode(...n.slice(0,16));_LOG("XHR magic string: "+r),r.startsWith("SQLite format 3")?(_LOG("‚úÖ SUCCESS: Valid GeoPackage file via XHR!"),o.__processGpkgData(e,t)):(_LOG("‚ö†Ô∏è Warning: XHR magic string is not 'SQLite format 3': "+r),_LOG("First 16 bytes: "+Array.from(n.slice(0,16)).map((e=>e.toString(16).padStart(2,"0"))).join(" ")),_LOG("Attempting to process anyway..."),o.__processGpkgData(e,t))}else _LOG("‚ö†Ô∏è Warning: XHR response too short to check magic number"),o.__processGpkgData(e,t)}else _LOG("XHR failed with status: "+r.status+" "+r.statusText),void 0!==t&&t.error?t.error("XHR failed: "+r.status+" "+r.statusText):a("XHR failed: "+r.status+" "+r.statusText)},r.onerror=function(){_LOG("XHR network error"),void 0!==t&&t.error?t.error("XHR network error"):a("XHR network error")},r.send()},s.Feed.prototype.__processGpkgData=function(t,o){const r=this;_LOG("Processing GeoPackage data, buffer size: "+t.byteLength+" bytes"),s.log("üì¶ Starting GeoPackage processing with DuckDB spatial extension..."),e.duckdb&&e.duckdb.db&&e.duckdb.conn?r.__testAndUseDuckDB(t,o):r.__loadDuckDBAndProcessGpkg(t,o)},s.Feed.prototype.__testAndUseDuckDB=function(t,o){const r=this;e.duckdb.conn.query("SELECT 1 as test").then((e=>{r.__processGpkgWithDuckDB(t,o)})).catch((e=>{r.__cleanupDuckDB(),r.__loadDuckDBAndProcessGpkg(t,o)}))},s.Feed.prototype.__cleanupDuckDB=function(){try{if(e.duckdb){if(e.duckdb.conn)try{e.duckdb.conn.close()}catch(e){}if(e.duckdb.db)try{e.duckdb.db.terminate()}catch(e){}if(e.duckdb.worker)try{e.duckdb.worker.terminate()}catch(e){}}}catch(e){}finally{delete e.duckdb,delete e.duckdbLoadedForGpkg}},s.Feed.prototype.__loadDuckDBAndProcessGpkg=function(o,r){const n=this;_LOG("Loading DuckDB WASM module for GeoPackage..."),e.__pendingGpkgBuffer=o,e.__pendingGpkgOpt=r;const s=t.createElement("script");s.type="module",s.textContent='\n            // Try to load DuckDB WASM from CDN\n            let duckdb;\n            try {\n                // Try jsDelivr first (most reliable for DuckDB WASM)\n                duckdb = await import("https://cdn.jsdelivr.net/npm/@duckdb/duckdb-wasm@latest/+esm");\n                console.log("‚úÖ DuckDB loaded from jsDelivr for GeoPackage");\n            } catch (e1) {\n                try {\n                    // Fallback to ESM.sh\n                    duckdb = await import("https://esm.sh/@duckdb/duckdb-wasm@1.30.0");\n                    console.log("‚úÖ DuckDB loaded from ESM.sh for GeoPackage");\n                } catch (e2) {\n                    try {\n                        // Fallback to unpkg\n                        duckdb = await import("https://unpkg.com/@duckdb/duckdb-wasm@1.30.0");\n                        console.log("‚úÖ DuckDB loaded from unpkg for GeoPackage");\n                    } catch (e3) {\n                        throw new Error("Failed to load DuckDB from any CDN: " + e3.message);\n                    }\n                }\n            }\n            \n            console.log("DuckDB WASM module imported for GeoPackage:", duckdb);\n            console.log("Available DuckDB methods:", Object.keys(duckdb));\n            \n            // Initialize DuckDB using CDN bundles\n            // CRITICAL: GeoPackage requires spatial extension, which MVP bundle doesn\'t support!\n            // We MUST use EH bundle for GeoPackage (even though it uses pthread workers)\n            try {\n                console.log(\'üîß Selecting bundle from jsDelivr CDN for GeoPackage...\');\n                const JSDELIVR_BUNDLES = duckdb.getJsDelivrBundles();\n                \n                // IMPORTANT: Must use EH bundle for GeoPackage (supports spatial extension)\n                // MVP bundle does NOT support dynamic extensions needed for spatial\n                console.log(\'üéØ Using EH bundle for GeoPackage (required for spatial extension)...\');\n                const bundle = JSDELIVR_BUNDLES.eh;\n                console.log(\'‚úÖ Using EH bundle:\', bundle);\n                \n                console.log("üë∑ Creating worker from bundle...");\n                \n                let worker;\n                try {\n                    // Create worker using blob URL approach to avoid CORS issues\n                    const worker_url = URL.createObjectURL(\n                        new Blob([`importScripts("${bundle.mainWorker}");`], { type: \'text/javascript\' })\n                    );\n                    worker = new Worker(worker_url);\n                    console.log("‚úÖ Worker created successfully for GeoPackage");\n                } catch (workerError) {\n                    console.error("‚ùå Failed to create Web Worker:", workerError);\n                    throw new Error("Worker creation failed: " + workerError.message + ". This may be due to browser resource limits. Try refreshing the page.");\n                }\n                \n                const logger = new duckdb.ConsoleLogger();\n                const db = new duckdb.AsyncDuckDB(logger, worker);\n                \n                // EH bundle supports pthread, so we pass pthreadWorker\n                console.log("üöÄ Instantiating DuckDB with WASM module...");\n                await db.instantiate(bundle.mainModule, bundle.pthreadWorker);\n                console.log("‚úÖ DuckDB instantiated for GeoPackage with EH bundle (spatial support enabled)");\n                \n                const conn = await db.connect();\n                console.log("‚úÖ DuckDB connection established for GeoPackage");\n                \n                // Store globally with worker reference for cleanup\n                window.duckdb = { \n                    module: duckdb,\n                    worker: worker,\n                    db: db, \n                    conn: conn \n                };\n                window.duckdbLoadedForGpkg = true;\n            } catch (initError) {\n                console.error("‚ùå DuckDB initialization error for GeoPackage:", initError);\n                throw initError;\n            }\n        ';const i=setInterval((function(){e.duckdbLoadedForGpkg&&e.duckdb&&(clearInterval(i),_LOG("DuckDB WASM module loaded successfully for GeoPackage"),n.__processGpkgWithDuckDB(e.__pendingGpkgBuffer,e.__pendingGpkgOpt),delete e.__pendingGpkgBuffer,delete e.__pendingGpkgOpt,delete e.duckdbLoadedForGpkg)}),100);setTimeout((function(){e.duckdbLoadedForGpkg||(clearInterval(i),_LOG("Failed to load DuckDB WASM module for GeoPackage"),delete e.__pendingGpkgBuffer,delete e.__pendingGpkgOpt,void 0!==r&&r.error?r.error("Failed to load DuckDB WASM module for GeoPackage"):a("Failed to load DuckDB WASM module for GeoPackage"))}),3e4),t.head.appendChild(s)},s.Feed.prototype.__ensureSpatialExtension=function(t,o){_LOG("Checking DuckDB spatial extension..."),e.duckdb.conn.query("INSTALL spatial;").then((function(){return _LOG("Spatial extension installed (or already present)"),e.duckdb.conn.query("LOAD spatial;")})).then((function(){_LOG("‚úÖ Spatial extension loaded successfully"),s.log("‚úÖ DuckDB spatial extension ready for GeoPackage"),t()})).catch((function(r){_LOG("Note: "+r.message),e.duckdb.conn.query("LOAD spatial;").then((function(){_LOG("Spatial extension loaded on second attempt"),t()})).catch((function(e){_LOG("‚ùå Could not load spatial extension: "+e.message),o?o(e):"undefined"!=typeof opt&&opt.error?opt.error("DuckDB spatial extension not available: "+e.message):a("DuckDB spatial extension not available. Cannot process GeoPackage files.")}))}))},s.Feed.prototype.__processGpkgWithDuckDB=function(t,o){const r=this;try{if(_LOG("Processing GeoPackage with DuckDB spatial extension, buffer size: "+t.byteLength+" bytes"),t.byteLength<16)throw new Error("File too small to be a valid GeoPackage file");const n=new Uint8Array(t),i=String.fromCharCode(...n.slice(0,16));if(_LOG("GeoPackage magic string: "+i),!i.startsWith("SQLite format 3"))throw new Error("File does not appear to be a valid GeoPackage file (missing SQLite header). Magic: "+i);_LOG("Valid GeoPackage file detected, processing with DuckDB spatial extension..."),r.__ensureSpatialExtension((function(){const n="temp_gpkg_"+Date.now()+".gpkg",i=new Uint8Array(t);e.duckdb.db.registerFileBuffer(n,i).then((function(){return s.log("üì¶ Reading GeoPackage with ST_Read..."),e.duckdb.conn.query(`\n                            SELECT column_name \n                            FROM (DESCRIBE SELECT * FROM st_read('${n}'))\n                            WHERE column_type LIKE '%GEOMETRY%' OR column_type LIKE '%WKB%'\n                        `).then((function(t){let o,r=[];try{r=(t.toArray?t.toArray():t).map((e=>e.column_name||e[0]))}catch(e){}if(r.length>0){const e=r.map((e=>`ST_AsGeoJSON(${e}) as ${e}`)).join(", ");o=`\n                                    SELECT * EXCLUDE (${r.join(", ")}), \n                                           ${e}\n                                    FROM st_read('${n}')\n                                    LIMIT 10000000\n                                `}else o=`\n                                    SELECT *\n                                    FROM st_read('${n}')\n                                    LIMIT 10000000\n                                `;return e.duckdb.conn.query(o)}))})).then((async function(t){if(_LOG("DuckDB query result type: "+typeof t),!t)throw new Error("DuckDB query returned null/undefined");let i,a;if("function"==typeof t.toArray)i=t.toArray();else if("function"==typeof t.fetchAll)i=t.fetchAll();else{if(!Array.isArray(t))throw new Error("Cannot convert DuckDB result to array. Available methods: "+Object.getOwnPropertyNames(t).join(", "));i=t}if(0===i.length)throw new Error("No rows found in GeoPackage file");let l=null;if(t.schema&&t.schema.fields)a=t.schema.fields.map((e=>e.name)),l=r.__detectColumnTypes(t.schema),l&&_LOG("Schema-based optimization enabled - detected column types: "+l.join(", "));else if(t.columns)a=t.columns;else{if(!(i.length>0&&"object"==typeof i[0]))throw new Error("Cannot determine column names from DuckDB result");a=Object.keys(i[0])}if(_LOG("Extracted columns: "+a.join(", ")),0===a.length)throw new Error("No columns found in GeoPackage file");const c=a.filter((e=>{const t=(e||"").toLowerCase();return"geometry"===t||"geom"===t||"wkb_geometry"===t||"shape"===t||t.includes("geom")}));c.length&&(l||(l=a.map((()=>"other"))),c.forEach((e=>{const t=a.indexOf(e);-1!==t&&(l[t]="geometry")})));const u=[];if(i.length>1e7)throw new Error(`Dataset too large (${i.length} rows). Maximum supported: 10,000,000 rows.`);if(i.length>5e5&&s.log(`‚ö†Ô∏è Processing large GeoPackage dataset (${i.length} rows). This may take a while.`),i.length>1e5)return s.log("Large GeoPackage dataset detected, using streaming processing..."),r.__processStreamingDataset(i,a,l,n,o);if(i.length>5e4){const e=i.length>0&&Array.isArray(i[0]),t=i.length>0&&"object"==typeof i[0]&&null!==i[0]&&!Array.isArray(i[0]),o=a.length,n=(i.length,Math.min(2e6,Math.max(1e5,Math.floor(1e7/o))));l&&s.log("‚ö° Schema-based optimization active for GeoPackage dataset");try{const o=async(o,n)=>r.__scheduleIdleWork((s=>{for(let s=o;s<n;s++)u.push(r.__processRow(i[s],a,l,e,t))}),1e3),c=Date.now();let d=c;for(let e=0;e<i.length;e+=n){const t=Math.min(e+n,i.length);await o(e,t);const r=Date.now(),a=r-d;if(t%5e5==0||t===i.length||a>2e3){const e=((r-c)/1e3).toFixed(1),o=Math.round(t/((r-c)/1e3));let n="";if(performance.memory){const e=Math.round(performance.memory.usedJSHeapSize/1024/1024);n=` | Memory: ${e}MB / ${Math.round(performance.memory.totalJSHeapSize/1024/1024)}MB`}s.log(`Processing GeoPackage: ${t.toLocaleString()} / ${i.length.toLocaleString()} rows (${Math.round(t/i.length*100)}%) | ${o.toLocaleString()} rows/sec | ${e}s${n}`),d=r}}}catch(e){for(let e=0;e<i.length;e++)u.push(r.__processRow(i[e],a,l,i.length>0&&Array.isArray(i[0]),i.length>0&&"object"==typeof i[0]&&null!==i[0]&&!Array.isArray(i[0])))}}else{const e=i.length>0&&Array.isArray(i[0]),t=i.length>0&&"object"==typeof i[0]&&null!==i[0]&&!Array.isArray(i[0]);for(let o=0;o<i.length;o++)u.push(r.__processRow(i[o],a,l,e,t))}_LOG("Converted "+u.length+" GeoPackage rows with "+a.length+" columns");const d=[a];d.push(...u),_LOG("Created data array with "+d.length+" rows (including header)");try{e.duckdb.db.dropFile(n)}catch(e){}r.__createDataTableObject(d,"gpkg",o)})).catch((function(t){_LOG("Error in GeoPackage processing: "+t);try{e.duckdb.db.dropFile(n)}catch(e){}void 0!==o&&o.error?o.error("Error processing GeoPackage: "+t.message):a("Error processing GeoPackage: "+t.message)}))}),(function(e){_LOG("‚ùå Error loading spatial extension: "+e),void 0!==o&&o.error?o.error("Error loading DuckDB spatial extension: "+e.message):a("Error loading DuckDB spatial extension: "+e.message)}))}catch(e){_LOG("Error in DuckDB GeoPackage processing setup: "+e),void 0!==o&&o.error?o.error("Error setting up DuckDB GeoPackage processing: "+e.message):a("Error setting up DuckDB GeoPackage processing: "+e.message)}},s.Feed.prototype.__doFlatGeobufImport=function(e,t){_LOG("__doFlatGeobufImport: "+e);const o=this;s.log("Loading FlatGeobuf file from: "+e),t&&t.bbox?(_LOG("Bbox filter detected - using streaming mode with HTTP Range Requests"),s.log("üîç Using HTTP Range Requests for spatial filtering"),o.__loadFlatGeobufStreaming(e,t)):(_LOG("No bbox filter - loading entire file"),fetch(e).then((e=>{if(!e.ok)throw new Error(`HTTP error! status: ${e.status}`);return _LOG("Fetch successful, reading FlatGeobuf data..."),e.arrayBuffer()})).then((e=>{_LOG("FlatGeobuf data loaded: "+e.byteLength+" bytes");const r=new Uint8Array(e);if(r.length>=8){const e=Array.from(r.slice(0,8)).map((e=>e.toString(16).padStart(2,"0"))).join("");_LOG("Magic bytes: "+e)}o.__processFlatGeobufData(e,t)})).catch((r=>{_LOG("Fetch failed: "+r.message),_LOG("Falling back to XMLHttpRequest..."),o.__loadFlatGeobufWithXHR(e,t)})))},s.Feed.prototype.__loadFlatGeobufWithXHR=function(e,t){const o=this;_LOG("Loading FlatGeobuf with XMLHttpRequest...");const r=new XMLHttpRequest;r.open("GET",e,!0),r.responseType="arraybuffer",r.onload=function(){if(200===r.status){const e=r.response;_LOG("XHR successful: "+e.byteLength+" bytes"),o.__processFlatGeobufData(e,t)}else _LOG("XHR failed with status: "+r.status+" "+r.statusText),void 0!==t&&t.error?t.error("XHR failed: "+r.status+" "+r.statusText):a("XHR failed: "+r.status+" "+r.statusText)},r.onerror=function(){_LOG("XHR network error"),void 0!==t&&t.error?t.error("XHR network error"):a("XHR network error")},r.send()},s.Feed.prototype.__loadFlatGeobufStreaming=function(t,o){const r=this;_LOG("Loading FlatGeobuf with streaming and spatial filter..."),s.log("üåê Using HTTP Range Requests for efficient spatial filtering"),e.flatgeobuf?r.__streamFlatGeobufWithLib(t,o):r.__loadFlatGeobufLibAndStream(t,o)},s.Feed.prototype.__loadFlatGeobufLibAndStream=function(o,r){const n=this;_LOG("Loading FlatGeobuf library from CDN for streaming..."),e.__pendingFgbStreamUrl=o,e.__pendingFgbStreamOpt=r;const s=t.createElement("script");s.type="module",s.textContent='\n            // Try to load FlatGeobuf from CDN\n            let flatgeobuf;\n            try {\n                // Try jsDelivr with geojson subpath (most reliable)\n                flatgeobuf = await import("https://cdn.jsdelivr.net/npm/flatgeobuf@3.31.0/lib/mjs/geojson.js");\n                console.log("‚úÖ FlatGeobuf GeoJSON loaded from jsDelivr");\n            } catch (e1) {\n                console.warn("jsDelivr geojson failed:", e1);\n                try {\n                    // Try main package from jsDelivr\n                    flatgeobuf = await import("https://cdn.jsdelivr.net/npm/flatgeobuf@latest/+esm");\n                    console.log("‚úÖ FlatGeobuf loaded from jsDelivr (main)");\n                } catch (e2) {\n                    console.warn("jsDelivr main failed:", e2);\n                    try {\n                        // Fallback to unpkg with geojson\n                        flatgeobuf = await import("https://unpkg.com/flatgeobuf@3.31.0/lib/mjs/geojson.js");\n                        console.log("‚úÖ FlatGeobuf loaded from unpkg");\n                    } catch (e3) {\n                        console.warn("unpkg failed:", e3);\n                        try {\n                            // Fallback to ESM.sh\n                            flatgeobuf = await import("https://esm.sh/flatgeobuf@3.31.0/lib/mjs/geojson");\n                            console.log("‚úÖ FlatGeobuf loaded from esm.sh");\n                        } catch (e4) {\n                            console.error("‚ùå Failed to load FlatGeobuf from any CDN:", e4);\n                            throw new Error("Failed to load FlatGeobuf library from CDN: " + e4.message);\n                        }\n                    }\n                }\n            }\n            \n            // Store globally for reuse\n            console.log("FlatGeobuf module loaded, available exports:", Object.keys(flatgeobuf));\n            window.flatgeobuf = flatgeobuf;\n            \n            // Trigger streaming\n            window.dispatchEvent(new CustomEvent(\'flatgeobuf-streaming-ready\'));\n        ';const i=function(){const o=e.__pendingFgbStreamUrl,r=e.__pendingFgbStreamOpt;delete e.__pendingFgbStreamUrl,delete e.__pendingFgbStreamOpt,e.removeEventListener("flatgeobuf-streaming-ready",i),t.body.removeChild(s),n.__streamFlatGeobufWithLib(o,r)};e.addEventListener("flatgeobuf-streaming-ready",i),s.onerror=function(t){_LOG("‚ùå Failed to load FlatGeobuf library for streaming"),e.removeEventListener("flatgeobuf-streaming-ready",i),void 0!==r&&r.error?r.error("Failed to load FlatGeobuf library from CDN"):a("Failed to load FlatGeobuf library from CDN")},t.body.appendChild(s)},s.Feed.prototype.__streamFlatGeobufWithLib=function(t,o){const r=this;try{_LOG("Streaming FlatGeobuf with spatial filter from URL: "+t),s.log("üîÑ Streaming FlatGeobuf with spatial filter...");let n=null;if(e.flatgeobuf&&(n=e.flatgeobuf.deserialize||e.flatgeobuf.default?.deserialize||e.flatgeobuf.geojson?.deserialize||e.flatgeobuf.default?.geojson?.deserialize),!n)throw new Error("FlatGeobuf deserialize function not found. Available: "+Object.keys(e.flatgeobuf||{}).join(", "));_LOG("Found deserialize function, starting streaming...");const i=o.bbox;_LOG("Applying spatial filter - bbox: ["+i.join(", ")+"]"),s.log("üîç Spatial filter: ["+i.join(", ")+"]"),(async()=>{try{const e=[],a=Date.now();_LOG("Starting FlatGeobuf streaming deserialization with bbox filter...");const l={minX:i[0],minY:i[1],maxX:i[2],maxY:i[3]},c=n(t,l);for await(const t of c)e.push(t);const u=((Date.now()-a)/1e3).toFixed(2);_LOG("Streaming complete! Features: "+e.length+" in "+u+"s"),s.log("‚úÖ Loaded "+e.length+" features in "+u+"s (HTTP range requests)");const d={type:"FeatureCollection",features:e};r.__processGeoJsonData(d,o)}catch(e){_LOG("FlatGeobuf streaming not available (common with compressed servers): "+e.message),e.message&&(e.message.includes("DECODING")||e.message.includes("Failed to fetch"))?s.log("‚ÑπÔ∏è Using full download mode (server compression detected)"):s.log("‚ö†Ô∏è Using fallback download method"),_LOG("Downloading full file and filtering in memory"),fetch(t).then((e=>{if(!e.ok)throw new Error(`HTTP ${e.status}: ${e.statusText}`);return e.arrayBuffer()})).then((e=>{_LOG("Full file downloaded: "+e.byteLength+" bytes, applying bbox filter in memory"),s.log("Downloaded "+Math.round(e.byteLength/1048576*10)/10+" MB, filtering features..."),r.__processFlatGeobufData(e,o)})).catch((e=>{_LOG("Fallback download failed: "+e),void 0!==o&&o.error?o.error("Error loading FlatGeobuf: "+e.message):a("Error loading FlatGeobuf: "+e.message)}))}})()}catch(e){_LOG("Error setting up FlatGeobuf streaming: "+e),void 0!==o&&o.error?o.error("Error setting up FlatGeobuf streaming: "+e.message):a("Error setting up FlatGeobuf streaming: "+e.message)}},s.Feed.prototype.__processFlatGeobufData=function(t,o){const r=this;_LOG("Processing FlatGeobuf data, buffer size: "+t.byteLength+" bytes"),s.log("üì¶ Starting FlatGeobuf processing..."),e.flatgeobuf?r.__processFlatGeobufWithLib(t,o):r.__loadFlatGeobufLibAndProcess(t,o)},s.Feed.prototype.__loadFlatGeobufLibAndProcess=function(o,r){const n=this;_LOG("Loading FlatGeobuf library from CDN..."),e.__pendingFgbBuffer=o,e.__pendingFgbOpt=r;const s=t.createElement("script");s.type="module",s.textContent='\n            // Try to load FlatGeobuf from CDN\n            let flatgeobuf;\n            try {\n                // Try jsDelivr with geojson subpath (most reliable)\n                flatgeobuf = await import("https://cdn.jsdelivr.net/npm/flatgeobuf@3.31.0/lib/mjs/geojson.js");\n                console.log("‚úÖ FlatGeobuf GeoJSON loaded from jsDelivr");\n            } catch (e1) {\n                console.warn("jsDelivr geojson failed:", e1);\n                try {\n                    // Try main package from jsDelivr\n                    flatgeobuf = await import("https://cdn.jsdelivr.net/npm/flatgeobuf@latest/+esm");\n                    console.log("‚úÖ FlatGeobuf loaded from jsDelivr (main)");\n                } catch (e2) {\n                    console.warn("jsDelivr main failed:", e2);\n                    try {\n                        // Fallback to unpkg with geojson\n                        flatgeobuf = await import("https://unpkg.com/flatgeobuf@3.31.0/lib/mjs/geojson.js");\n                        console.log("‚úÖ FlatGeobuf loaded from unpkg");\n                    } catch (e3) {\n                        console.warn("unpkg failed:", e3);\n                        try {\n                            // Fallback to ESM.sh\n                            flatgeobuf = await import("https://esm.sh/flatgeobuf@3.31.0/lib/mjs/geojson");\n                            console.log("‚úÖ FlatGeobuf loaded from esm.sh");\n                        } catch (e4) {\n                            console.error("‚ùå Failed to load FlatGeobuf from any CDN:", e4);\n                            throw new Error("Failed to load FlatGeobuf library from CDN: " + e4.message);\n                        }\n                    }\n                }\n            }\n            \n            // Store globally for reuse\n            console.log("FlatGeobuf module loaded, available exports:", Object.keys(flatgeobuf));\n            window.flatgeobuf = flatgeobuf;\n            \n            // Trigger processing\n            window.dispatchEvent(new CustomEvent(\'flatgeobuf-loaded\'));\n        ';const i=function(){const o=e.__pendingFgbBuffer,r=e.__pendingFgbOpt;delete e.__pendingFgbBuffer,delete e.__pendingFgbOpt,e.removeEventListener("flatgeobuf-loaded",i),t.body.removeChild(s),n.__processFlatGeobufWithLib(o,r)};e.addEventListener("flatgeobuf-loaded",i),s.onerror=function(t){_LOG("‚ùå Failed to load FlatGeobuf library"),e.removeEventListener("flatgeobuf-loaded",i),void 0!==r&&r.error?r.error("Failed to load FlatGeobuf library from CDN"):a("Failed to load FlatGeobuf library from CDN")},t.body.appendChild(s)},s.Feed.prototype.__processFlatGeobufWithDuckDB=function(t,o){const r=this;_LOG("Processing FlatGeobuf with DuckDB WASM spatial extension..."),s.log("ü¶Ü Using DuckDB WASM to read FlatGeobuf file..."),e.duckdb&&e.duckdb.db?r.__processFgbWithDuckDB(t,o):(s.log("üì¶ Loading DuckDB WASM..."),r.__loadDuckDBAndProcessFgb(t,o))},s.Feed.prototype.__loadDuckDBAndProcessFgb=function(o,r){const n=this;_LOG("Loading DuckDB WASM module for FlatGeobuf..."),e.__pendingFgbBufferDuckDB=o,e.__pendingFgbOptDuckDB=r;const s=t.createElement("script");s.type="module",s.textContent='\n            // Try to load DuckDB WASM from CDN\n            let duckdb;\n            try {\n                // Try jsDelivr first (most reliable for DuckDB WASM)\n                duckdb = await import("https://cdn.jsdelivr.net/npm/@duckdb/duckdb-wasm@latest/+esm");\n                console.log("‚úÖ DuckDB loaded from jsDelivr for FlatGeobuf");\n            } catch (e1) {\n                try {\n                    // Fallback to ESM.sh\n                    duckdb = await import("https://esm.sh/@duckdb/duckdb-wasm@1.30.0");\n                    console.log("‚úÖ DuckDB loaded from ESM.sh for FlatGeobuf");\n                } catch (e2) {\n                    try {\n                        // Fallback to unpkg\n                        duckdb = await import("https://unpkg.com/@duckdb/duckdb-wasm@1.30.0/+esm");\n                        console.log("‚úÖ DuckDB loaded from unpkg for FlatGeobuf");\n                    } catch (e3) {\n                        console.error("‚ùå Failed to load DuckDB from any CDN:", e3);\n                        throw new Error("Failed to load DuckDB library from CDN: " + e3.message);\n                    }\n                }\n            }\n            \n            // Store module reference\n            window.duckdbModule = duckdb;\n            \n            // Check if window.duckdb already exists (from parquet/gpkg loading)\n            if (!window.duckdb || !window.duckdb.db) {\n                // Get bundles\n                const JSDELIVR_BUNDLES = duckdb.getJsDelivrBundles();\n                \n                // Force MVP bundle (single-threaded) to avoid pthread worker issues\n                console.log(\'üéØ Forcing MVP bundle (single-threaded) to avoid resource limits...\');\n                const bundle = JSDELIVR_BUNDLES.mvp;\n                console.log(\'‚úÖ Using MVP bundle for FlatGeobuf:\', bundle);\n                \n                console.log("üì¶ Creating DuckDB worker for FlatGeobuf...");\n                \n                // Create worker using blob URL to avoid CORS issues\n                const worker_url = URL.createObjectURL(\n                    new Blob([`importScripts("${bundle.mainWorker}");`], { type: \'text/javascript\' })\n                );\n                const worker = new Worker(worker_url);\n                URL.revokeObjectURL(worker_url);\n                \n                // Initialize DuckDB\n                const logger = new duckdb.ConsoleLogger();\n                const db = new duckdb.AsyncDuckDB(logger, worker);\n                // MVP bundle is single-threaded, so we don\'t pass pthreadWorker\n                await db.instantiate(bundle.mainModule);\n                \n                console.log("‚úÖ DuckDB initialized successfully for FlatGeobuf");\n                \n                // Create a new object to store db and connection (don\'t modify frozen module)\n                window.duckdb = {\n                    module: duckdb,\n                    worker: worker,\n                    db: db,\n                    conn: await db.connect()\n                };\n                window.duckdbLoaded = true;\n            } else {\n                console.log("‚úÖ Using existing DuckDB instance for FlatGeobuf");\n            }\n            \n            // Trigger processing\n            window.dispatchEvent(new CustomEvent(\'duckdb-fgb-loaded\'));\n        ';const i=function(){const o=e.__pendingFgbBufferDuckDB,r=e.__pendingFgbOptDuckDB;delete e.__pendingFgbBufferDuckDB,delete e.__pendingFgbOptDuckDB,e.removeEventListener("duckdb-fgb-loaded",i),t.body.removeChild(s),n.__processFgbWithDuckDB(o,r)};e.addEventListener("duckdb-fgb-loaded",i),s.onerror=function(t){_LOG("‚ùå Failed to load DuckDB for FlatGeobuf"),e.removeEventListener("duckdb-fgb-loaded",i),void 0!==r&&r.error?r.error("Failed to load DuckDB library from CDN"):a("Failed to load DuckDB library from CDN")},t.body.appendChild(s)},s.Feed.prototype.__processFgbWithDuckDB=function(t,o){const r=this;_LOG("Processing FlatGeobuf with DuckDB spatial extension..."),s.log("Reading FlatGeobuf with DuckDB spatial extension...");const n="temp_"+Date.now()+".fgb",i=e.duckdb.db,l=e.duckdb.conn;i.registerFileBuffer(n,new Uint8Array(t)).then((function(){return _LOG("FlatGeobuf file registered with DuckDB: "+n),l.query("INSTALL spatial; LOAD spatial;")})).then((function(){_LOG("DuckDB spatial extension loaded"),s.log("üîß Spatial extension loaded");const e=`SELECT column_name FROM (DESCRIBE SELECT * FROM st_read('${n}')) WHERE column_type LIKE '%GEOMETRY%' OR column_type LIKE '%WKB%'`;return l.query(e)})).then((function(e){const t=[];for(let o=0;o<e.numRows;o++)t.push(e.get(o).column_name);_LOG("Detected geometry columns: "+t.join(", "));let r="*",i="";if(t.length>0){if(r=`${t.map((e=>`ST_AsGeoJSON(${e}) AS ${e}`)).join(", ")}, * EXCLUDE (${t.join(", ")})`,o&&o.bbox&&t.length>0){const[e,r,n,a]=o.bbox;i=` WHERE ST_Intersects(${t[0]}, ST_MakeEnvelope(${e}, ${r}, ${n}, ${a}))`,_LOG("Applying spatial filter in DuckDB - bbox: ["+o.bbox.join(", ")+"]"),s.log("üîç Applying spatial filter in DuckDB: ["+o.bbox.join(", ")+"]")}}const a=`SELECT ${r} FROM st_read('${n}')${i}`;return _LOG("Executing query: "+a),l.query(a)})).then((function(e){_LOG("DuckDB query successful, rows: "+e.numRows),s.log(`‚úÖ Loaded ${e.numRows} features from FlatGeobuf`);const t=e.toArray().map((e=>Object.fromEntries(e))),i=e.schema.fields.map((e=>e.name));_LOG("Converting DuckDB result to table format...");const a=r.__detectColumnTypes(e.schema);r.__processStreamingDataset(t,i,a,n,o)})).catch((function(e){_LOG("Error processing FlatGeobuf with DuckDB: "+e),void 0!==o&&o.error?o.error("Error processing FlatGeobuf with DuckDB: "+e.message):a("Error processing FlatGeobuf with DuckDB: "+e.message)}))},s.Feed.prototype.__processFlatGeobufWithLib=function(t,o){const r=this;try{_LOG("Converting FlatGeobuf to GeoJSON..."),s.log("üîÑ Converting FlatGeobuf to GeoJSON...");const n=new Uint8Array(t);let i=null;if(e.flatgeobuf&&(i=e.flatgeobuf.deserialize||e.flatgeobuf.default?.deserialize||e.flatgeobuf.geojson?.deserialize||e.flatgeobuf.default?.geojson?.deserialize),!i)throw _LOG("Available properties: "+Object.keys(e.flatgeobuf||{}).join(", ")),new Error("FlatGeobuf deserialize function not found. Available: "+Object.keys(e.flatgeobuf||{}).join(", "));_LOG("Found deserialize function, processing FlatGeobuf data...");let l=null;o&&o.bbox&&(l=o.bbox,_LOG("Applying spatial filter - bbox: ["+l.join(", ")+"]"),s.log("üîç Applying spatial filter: ["+l.join(", ")+"]"));const c=new ReadableStream({start(e){e.enqueue(n),e.close()}});(async()=>{try{const e=[];let t;if(_LOG("Starting FlatGeobuf deserialization from ReadableStream..."),l){const e={minX:l[0],minY:l[1],maxX:l[2],maxY:l[3]};_LOG("Applying bbox filter to stream: "+JSON.stringify(e)),t=i(c,e)}else t=i(c);for await(const o of t)e.push(o);_LOG("Converted "+e.length+" features from FlatGeobuf"),s.log("‚úÖ Converted "+e.length+" features from FlatGeobuf");const n={type:"FeatureCollection",features:e};r.__processGeoJsonData(n,o)}catch(e){_LOG("Error in FlatGeobuf deserialization: "+e),e.message&&e.message.includes("JSON")?(s.log("üîÑ Switching to DuckDB WASM for better FlatGeobuf compatibility..."),_LOG("FlatGeobuf library failed with data parsing issue, using DuckDB fallback"),r.__processFlatGeobufWithDuckDB(t,o)):void 0!==o&&o.error?o.error("Error processing FlatGeobuf: "+e.message):a("Error processing FlatGeobuf: "+e.message)}})()}catch(e){_LOG("Error in FlatGeobuf processing: "+e),void 0!==o&&o.error?o.error("Error processing FlatGeobuf: "+e.message):a("Error processing FlatGeobuf: "+e.message)}},s.Feed.prototype.__doGeobufImport=function(e,t){_LOG("__doGeobufImport: "+e);const o=this;s.log("Loading Geobuf file from: "+e),fetch(e).then((e=>{if(!e.ok)throw new Error(`HTTP error! status: ${e.status}`);return _LOG("Fetch successful, reading Geobuf data..."),e.arrayBuffer()})).then((e=>{_LOG("Geobuf data loaded: "+e.byteLength+" bytes");const r=new Uint8Array(e);r.length>=4&&_LOG("Geobuf file size: "+r.length+" bytes"),o.__processGeobufData(e,t)})).catch((r=>{_LOG("Fetch failed: "+r.message),_LOG("Falling back to XMLHttpRequest..."),o.__loadGeobufWithXHR(e,t)}))},s.Feed.prototype.__loadGeobufWithXHR=function(e,t){const o=this;_LOG("Loading Geobuf with XMLHttpRequest...");const r=new XMLHttpRequest;r.open("GET",e,!0),r.responseType="arraybuffer",r.onload=function(){if(200===r.status){const e=r.response;_LOG("XHR successful: "+e.byteLength+" bytes"),o.__processGeobufData(e,t)}else _LOG("XHR failed with status: "+r.status+" "+r.statusText),void 0!==t&&t.error?t.error("XHR failed: "+r.status+" "+r.statusText):a("XHR failed: "+r.status+" "+r.statusText)},r.onerror=function(){_LOG("XHR network error"),void 0!==t&&t.error?t.error("XHR network error"):a("XHR network error")},r.send()},s.Feed.prototype.__processGeobufData=function(t,o){const r=this;_LOG("Processing Geobuf data, buffer size: "+t.byteLength+" bytes"),s.log("üì¶ Starting Geobuf processing..."),e.geobuf&&e.Pbf?r.__processGeobufWithLib(t,o):r.__loadGeobufLibAndProcess(t,o)},s.Feed.prototype.__loadGeobufLibAndProcess=function(o,r){const n=this;_LOG("Loading Geobuf library from CDN..."),e.__pendingPbfBuffer=o,e.__pendingPbfOpt=r;const s=t.createElement("script");s.type="module",s.textContent='\n            // Try to load Geobuf and Pbf from CDN\n            let geobuf, Pbf;\n            try {\n                // Try jsDelivr first\n                geobuf = await import("https://cdn.jsdelivr.net/npm/geobuf@3.0.2/+esm");\n                Pbf = await import("https://cdn.jsdelivr.net/npm/pbf@3.2.1/+esm");\n                console.log("‚úÖ Geobuf and Pbf loaded from jsDelivr");\n            } catch (e1) {\n                console.warn("jsDelivr failed:", e1);\n                try {\n                    // Fallback to unpkg\n                    geobuf = await import("https://unpkg.com/geobuf@3.0.2/dist/geobuf.js");\n                    Pbf = await import("https://unpkg.com/pbf@3.2.1/dist/pbf.js");\n                    console.log("‚úÖ Geobuf and Pbf loaded from unpkg");\n                } catch (e2) {\n                    console.warn("unpkg failed:", e2);\n                    try {\n                        // Fallback to ESM.sh\n                        geobuf = await import("https://esm.sh/geobuf@3.0.2");\n                        Pbf = await import("https://esm.sh/pbf@3.2.1");\n                        console.log("‚úÖ Geobuf and Pbf loaded from esm.sh");\n                    } catch (e3) {\n                        console.error("‚ùå Failed to load Geobuf from any CDN:", e3);\n                        throw new Error("Failed to load Geobuf library from CDN: " + e3.message);\n                    }\n                }\n            }\n            \n            // Store globally for reuse\n            console.log("Geobuf module loaded, available exports:", Object.keys(geobuf));\n            console.log("Pbf module loaded, available exports:", Object.keys(Pbf));\n            window.geobuf = geobuf;\n            window.Pbf = Pbf;\n            \n            // Trigger processing\n            window.dispatchEvent(new CustomEvent(\'geobuf-loaded\'));\n        ';const i=function(){const o=e.__pendingPbfBuffer,r=e.__pendingPbfOpt;delete e.__pendingPbfBuffer,delete e.__pendingPbfOpt,e.removeEventListener("geobuf-loaded",i),t.body.removeChild(s),n.__processGeobufWithLib(o,r)};e.addEventListener("geobuf-loaded",i),s.onerror=function(t){_LOG("‚ùå Failed to load Geobuf library"),e.removeEventListener("geobuf-loaded",i),void 0!==r&&r.error?r.error("Failed to load Geobuf library from CDN"):a("Failed to load Geobuf library from CDN")},t.body.appendChild(s)},s.Feed.prototype.__processGeobufWithLib=function(t,o){const r=this;try{_LOG("Converting Geobuf to GeoJSON..."),s.log("üîÑ Converting Geobuf to GeoJSON...");const n=new Uint8Array(t);let i=null;e.geobuf&&(i=e.geobuf.decode||e.geobuf.default?.decode||e.geobuf.default?.geobuf?.decode);let a=null;if(e.Pbf&&(a=e.Pbf.default||e.Pbf.Pbf||e.Pbf),!i)throw _LOG("Available geobuf properties: "+Object.keys(e.geobuf||{}).join(", ")),new Error("Geobuf decode function not found. Available: "+Object.keys(e.geobuf||{}).join(", "));if(!a)throw _LOG("Available Pbf properties: "+Object.keys(e.Pbf||{}).join(", ")),new Error("Pbf constructor not found. Available: "+Object.keys(e.Pbf||{}).join(", "));_LOG("Found decode function and Pbf constructor, processing Geobuf data...");const l=i(new a(n));_LOG("Converted Geobuf to GeoJSON successfully"),s.log("‚úÖ Converted Geobuf to GeoJSON successfully"),r.__processGeoJsonData(l,o)}catch(e){_LOG("Error in Geobuf processing: "+e),void 0!==o&&o.error?o.error("Error processing Geobuf: "+e.message):a("Error processing Geobuf: "+e.message)}},s.Feed.prototype.__createDataTableObject=function(e,t,o){if(e)return this.dbtable=(new s.Table).setArray(e),e=null,void(void 0!==o&&o.success?o.success(this.dbtable):_LOG("callback to call on succes is 'undefined'!"))},s.Table=function(e){e?(this.table=e.table,this.fields=e.fields,this.records=e.records):(this.table={records:0,fields:0},this.fields=[],this.records=[])},s.Table.prototype={getArray:function(){let e=[[]];for(let t=0,o=this.fields.length;t<o;t++)e[0].push(this.fields[t].id);for(let t=0,o=this.records.length;t<o;t++)e.push(this.records[t]);return e},setArray:function(e){if(e.length<2)return this;this.fields=[];for(let t=0,o=e[0].length;t<o;t++)this.fields.push({id:(e[0][t]||" ").trim(),typ:0,width:60,decimals:0});e.shift(),this.records=[];for(let t=0,o=e.length;t<o;t++)e[t].length==this.fields.length&&this.records.push(e[t]);return this.table={records:this.records.length,fields:this.fields.length},this},revert:function(){let e=[];for(let t=this.records.length-1;t>=0;t--)e.push(this.records[t]);return this.records=e,this},reverse:function(){let e=[];for(let t=this.records.length-1;t>=0;t--)e.push(this.records[t]);return this.records=e,this},columnNames:function(){const e=[];for(let t=0,o=this.fields.length;t<o;t++)e.push(this.fields[t].id);return e},columnIndex:function(e){for(var t in this.fields)if(this.fields[t].id==e)return t;return null},column:function(e){for(let t in this.fields)if(this.fields[t].id==e){const e=new s.Column;return e.index=t,e.table=this,e}return null},lookupArray:function(e,t){let o="overwrite";e&&e.key&&(o=e.calc||o,t=e.key,e=e.value);let r=[];this.column(t)||alert("'"+t+"' column not found!"),this.column(e)||alert("'"+e+"' column not found!");const n=this.column(t).values(),s=this.column(e).values();if("sum"==o)for(let e=0,t=n.length;e<t;e++)r[String(n[e])]=(r[String(n[e])]||0)+s[e];else if("max"==o)for(let e=0,t=n.length;e<t;e++)r[String(n[e])]=Math.max(r[String(n[e])]||0,s[e]);else for(let e=0,t=n.length;e<t;e++)r[String(n[e])]=s[e];return r},lookupStringArray:function(e,t){e&&e.key&&(t=e.key,e=e.value);let o=[];this.column(t)||alert("'"+t+"' column not found!"),this.column(e)||alert("'"+e+"' column not found!");const r=this.column(t).values(),n=this.column(e).values();for(let e=0,t=r.length;e<t;e++)o[String(r[e])]=o[String(r[e])]?o[String(r[e])]+", "+n[e]:n[e];return o},lookup:function(e,t){const o=t.value,r=t.lookup,n=o+"_"+r;return this.lookupsA&&this.lookupsA[n]||(this.lookupsA=this.lookupsA||[],this.lookupsA[n]=this.lookupArray(o,r)),this.lookupsA[n][e]||"-"},toKeyValue:function(e){return this.lookupArray(e.value,e.key)},addColumn:function(e,t){if(!e.destination)return alert("'data.addColumn' no destination defined!"),null;var o=null,r=null;if(e.source)if(Array.isArray(e.source)){r=[];const t=[];for(let o=0;o<e.source.length;o++){const n=e.source[o];let s=!1;for(let e=0,t=this.fields.length;e<t;e++)if(this.fields[e].id==n){r.push(e),s=!0;break}s||t.push(n)}if(t.length>0)return alert("'data.addColumn' source columns not found: "+t.join(", ")),null;if(0===r.length)return alert("'data.addColumn' no valid source columns provided!"),null}else{for(let t=0,r=this.fields.length;t<r;t++)if(this.fields[t].id==e.source){o=t;break}if(null==o)return alert("'data.addColumn' source column '"+e.source+"' not found!"),null}if(this.fields.push({id:String(e.destination),created:!0}),this.table.fields++,t&&"function"==typeof t)for(let e=0,n=this.records.length;e<n;e++){let n;if(null!==r){const o=r.map((t=>this.records[e][t]));n=t.apply(null,o.concat([this.records[e]]))}else n=null!=o?t(this.records[e][o],this.records[e]):t(this.records[e]);this.records[e].push(n)}else if(t&&"object"==typeof t)for(let e=0,o=this.records.length;e<o;e++)this.records[e].push(t[e]||0);else if(e.values&&"object"==typeof e.values)for(let t=0,o=this.records.length;t<o;t++)this.records[t].push(e.values[t]||0);else for(let e=0,t=this.records.length;e<t;e++)this.records[e].push(0);return this},addRow:function(e){if(!e||"object"!=typeof e)return alert("'data.addRow' no options defined!"),null;var t=[];for(let e=0,o=this.fields.length;e<o;e++)t.push("");for(var o in e)this.column(o)?t[this.column(o).index]=e[o]:alert("'data.addRow' column '"+o+"' not found!");return this.records.push(t),this.table.records++,this},filter:function(e){this.selection=new s.Table;for(const t in this.records)e&&e(this.records[t])&&(this.selection.records.push(this.records[t]),this.selection.table.records++);return this.selection.fields=this.fields.slice(),this.selection.table.fields=this.table.fields,this.selection},select:function(e){if(e.match(/WHERE/)){if(1){let t=e.split("WHERE")[1].trim().split(" ");for(let e=0;e<t.length;e++)if(t[e].length){if('"'==t[e][0]&&'"'!=t[e][t[e].length-1])do{t[e]=t[e]+" "+t[e+1],t.splice(e+1,1)}while('"'!=t[e][t[e].length-1]);if("("==t[e][0]&&")"!=t[e][t[e].length-1])do{t[e]=t[e]+" "+t[e+1],t.splice(e+1,1)}while(")"!=t[e][t[e].length-1])}else t.splice(e,1),e--;this.filterQueryA=[];let o={},r="";do{let n=0;if(t.length>=3&&(o={},o.szSelectionField=t[0].replace(/("|)/g,""),o.szSelectionOp=t[1],"IN"==t[1].toUpperCase()&&t[2].startsWith("(")&&t[2].endsWith(")")?o.szSelectionValue=t[2]:o.szSelectionValue=t[2].replace(/("|)/g,""),n=3),"BETWEEN"==o.szSelectionOp&&t.length>=5&&"AND"==t[3]&&(o.szSelectionValue2=t[4],n=5),!n){a("data.js - selection error - incomplete query!\nquery: "+e);break}for(let e=0;e<this.fields.length;e++)this.fields[e].id==o.szSelectionField&&(o.nFilterFieldIndex=e),"$"+this.fields[e].id+"$"==o.szSelectionValue&&(o.nFilterValueIndex=e);if(o.szCombineOp=r,this.filterQueryA.push(o),t.splice(0,n),t.length&&"AND"==t[0])r="AND",t.splice(0,1);else{if(!t.length||"OR"!=t[0])break;r="OR",t.splice(0,1)}}while(t.length)}this.selection=new s.Table;for(let t=0;t<this.filterQueryA.length;t++)if(void 0===this.filterQueryA[t].nFilterFieldIndex)return this.selection.fields=this.fields.slice(),this.selection.table.fields=this.table.fields,_LOG("Selection: invalid query: "+e),this.selection;for(let e=0,t=this.records.length;e<t;e++){let t=null;for(let o=0,r=this.filterQueryA.length;o<r;o++){let r=!0;this.__szValue=String(this.records[e][this.filterQueryA[o].nFilterFieldIndex]),this.__szSelectionOp=this.filterQueryA[o].szSelectionOp.toUpperCase(),this.__szSelectionValue=this.filterQueryA[o].szSelectionValue,this.__szSelectionValue2=this.filterQueryA[o].szSelectionValue2,this.__szCombineOp=this.filterQueryA[o].szCombineOp,null!=this.filterQueryA[o].nFilterValueIndex&&(this.__szSelectionValue=String(this.records[e][this.filterQueryA[o].nFilterValueIndex]));let n=__scanValue(this.__szValue);if("="==this.__szSelectionOp)r="*"==this.__szSelectionValue?""!=this.__szValue.replace(/ /g,""):this.__szValue==this.__szSelectionValue||n==Number(this.__szSelectionValue);else if("<>"==this.__szSelectionOp)r=!(this.__szValue==this.__szSelectionValue||n==Number(this.__szSelectionValue));else if(">"==this.__szSelectionOp)r=n>Number(this.__szSelectionValue);else if("<"==this.__szSelectionOp)r=n<Number(this.__szSelectionValue);else if(">="==this.__szSelectionOp)r=n>=Number(this.__szSelectionValue);else if("<="==this.__szSelectionOp)r=n<=Number(this.__szSelectionValue);else if("LIKE"==this.__szSelectionOp)if("*"==this.__szSelectionValue)r=this.__szValue.length;else{const e=this.__szSelectionValue.replace(/[.*+?^${}()|[\]\\]/g,"\\$&");r=new RegExp(e,"i").test(this.__szValue)}else if("NOT"==this.__szSelectionOp){const e=this.__szSelectionValue.replace(/[.*+?^${}()|[\]\\]/g,"\\$&");r=!new RegExp(e,"i").test(this.__szValue)}else if("IN"==this.__szSelectionOp){let e=this.__szSelectionValue;e.startsWith("(")&&e.endsWith(")")&&(e=e.slice(1,-1));const t=e.split(",").map((e=>e.trim().replace(/^["']|["']$/g,""))),o=t.includes(this.__szValue),n=__scanValue(this.__szValue),s=!isNaN(n)&&t.some((e=>{const t=Number(e);return!isNaN(t)&&n===t}));r=o||s}else if("BETWEEN"==this.__szSelectionOp)r=n>=Number(this.__szSelectionValue)&&n<=Number(this.__szSelectionValue2);else{const e=this.__szSelectionValue.replace(/[.*+?^${}()|[\]\\]/g,"\\$&");r=new RegExp(e,"i").test(this.__szValue)}t="AND"==this.__szCombineOp?t&&r:t||r}t&&(this.selection.records.push(this.records[e].slice()),this.selection.table.records++)}}return this.selection.fields=this.fields.slice(),this.selection.table.fields=this.table.fields,this.selection},aggregate:function(e,t){let o=!1;e.lead&&(o=e.calc&&"mean"==e.calc,t=e.lead,e=e.column||e.value);const r=t.split("|"),n=[];let i=null;for(let t=0;t<r.length;t++)for(let o=0;o<this.fields.length;o++)this.fields[o].id==r[t]&&(n[t]=o),this.fields[o].id==e&&(i=o);this.aggregation=new s.Table,xRecords=[],xCount=[];for(let e=0,t=this.records.length;e<t;e++){const t=[];for(let o=0,r=n.length;o<r;o++)t.push(this.records[e][n[o]]);const o=t.join("");if(xRecords[o])xRecords[o][n.length]+=__scanValue(this.records[e][i]),xCount[o][n.length]++;else{xRecords[o]=[],xRecords[o][n.length]=__scanValue(this.records[e][i]);for(let t=0;t<n.length;t++)xRecords[o][t]=this.records[e][n[t]];xCount[o]=[],xCount[o][n.length]=1}}for(let e=0,t=xRecords.length;e<t;e++)o&&(xRecords[e][n.length]/=xCount[e][n.length]),this.aggregation.records.push(xRecords[e]),this.aggregation.table.records++;const a=[];for(let e=0;e<r.length;e++)a[e]={id:r[e]};return a[r.length]={id:e},this.aggregation.fields=a,this.aggregation.table.fields=a,this.aggregation},condense:function(e,t){const o={},r=[];e&&e.lead&&(e=(t=e).lead);const n=this.columnIndex(e);if(t&&t.keep)if("string"==typeof t.keep)r[this.columnIndex(t.keep)]=!0;else for(i=0;i<t.keep.length;i++)r[this.columnIndex(t.keep[i])]=!0;const a=[];for(let e=0;e<this.records.length;e++){const s=String(this.records[e][n]);if(null!=o[s]){const n=o[s];for(let o=0,s=this.records[e].length;o<s;o++)if(!r[o])if(isNaN(this.records[e][o])){if(isNaN(this.records[e][o])&&a[n][o]!=this.records[e][o]){let e=parseFloat(String(a[n][o]).split(" (+")[1])||0;a[n][o]=String(a[n][o]).split(" (+")[0]+" (+"+ ++e+") "}}else t&&"max"==t.calc?a[n][o]=Math.max(Number(a[n][o]),Number(this.records[e][o])):a[n][o]=Number(a[n][o])+Number(this.records[e][o])}else a.push(this.records[e].slice()),o[s]=a.length-1}return this.__condense=new s.Table,this.__condense.fields=this.fields,this.__condense.table.fields=this.fields,this.__condense.records=a.slice(),this.__condense.table.records=this.__condense.records.length,this.__condense},groupColumns:function(e){let t=e.source,o=[];for(let e=0,r=t.length;e<r;e++)o[e]=this.column(t[e]).index;return this.addColumn({destination:e.destination},(function(e){let t=0;for(let r=0,n=o.length;r<n;r++)t+=Number(e[o[r]]);return t})),this},pivot:function(e){e.lead=e.lead||e.rows,e.cols=e.cols||e.columns,e.keep=e.keep||[],e.sum=e.sum||[],e.lead=r(e.lead),e.cols=r(e.cols),e.keep=r(e.keep),e.sum=r(e.sum),e.value=r(e.value),e.forced=r(e.forced);let t=[];for(let e=0;e<this.fields.length;e++)t[String(this.fields[e].id)]=e;for(let o=0,r=e.lead.length;o<r;o++)void 0===t[e.lead[o]]&&a("data.pivot - pivot keep column '"+e.lead[o]+"' not found");for(let o=0,r=e.cols.length;o<r;o++)e.cols&&void 0===t[e.cols[o]]&&a("data.pivot - pivot columns source column '"+e.cols[o]+"' not found");for(let o=0,r=e.keep.length;o<r;o++)void 0===t[e.keep[o]]&&a("data.pivot - pivot keep column '"+e.keep[o]+"' not found");for(let o=0,r=e.sum.length;o<r;o++)void 0===t[e.sum[o]]&&a("data.pivot - pivot sum column '"+e.sum[o]+"' not found");for(let o=0,r=e.value.length;o<r;o++)void 0===t[e.value[o]]&&a("data.pivot - pivot value column '"+e.value[o]+"' not found");let o=[],n=[],i=this.records;if(e.forced)for(let t=0;t<e.forced.length;t++)n[String(e.forced[t])]=0;for(let r=0,s=i.length;r<s;r++){const s=[i[r][t[e.lead[0]]]];for(let o=1;o<e.lead.length;o++)s.push(i[r][t[e.lead[o]]]);const a=s.join("|");let l=String(i[r][t[e.cols[0]]]),c=null;if("string"==e.calc)c=i[r][t[e.value[0]]];else if(c=1,e.value&&e.value.length){c=0;for(let o=0;o<e.value.length;o++)c+=e.value[o]?__scanValue(i[r][t[e.value[o]]]):1}if((!l||l.length<1)&&(l="undefined"),void 0===n[l]&&(n[l]=0),o[a]){for(let n=0;n<e.keep.length;n++)i[r][t[e.keep[n]]]&&i[r][t[e.keep[n]]].length&&o[a][e.keep[n]]!=i[r][t[e.keep[n]]]&&(o[a][e.keep[n]]=i[r][t[e.keep[n]]]);for(let n=0;n<e.sum.length;n++)o[a][e.sum[n]]+=Number(i[r][t[e.sum[n]]])}else{o[a]={Total:0};for(let n=0;n<e.keep.length;n++)o[a][e.keep[n]]=i[r][t[e.keep[n]]];for(let n=0;n<e.sum.length;n++)o[a][e.sum[n]]=Number(i[r][t[e.sum[n]]])}o[a].Total+=c,o[a][l]?(e.calc,"max"==e.calc?o[a][l]=Math.max(c,o[a][l]):(o[a][l]+=c,o[a][l+"count"]++)):(o[a][l]=c,o[a][l+"count"]=1)}this.__pivot=new s.Table;for(let t=0;t<e.lead.length;t++)this.__pivot.fields.push({id:e.lead[t]});for(let t=0;t<e.keep.length;t++)this.__pivot.fields.push({id:e.keep[t]});for(let t=0;t<e.sum.length;t++)this.__pivot.fields.push({id:e.sum[t]});if(e.cols&&e.cols.length)for(let e in n)Object.prototype.hasOwnProperty.call(n,e)&&this.__pivot.fields.push({id:e});this.__pivot.fields.push({id:"Total"});for(let t in o)if(Object.prototype.hasOwnProperty.call(o,t)){const r=[],s=t.split("|");if(e.lead&&e.lead.length)for(let e=0;e<s.length;e++)r.push(s[e]);for(let n=0;n<e.keep.length;n++)r.push(o[t][e.keep[n]]);for(let n=0;n<e.sum.length;n++)r.push(o[t][e.sum[n]]);if(e.cols&&e.cols.length)for(let s in n)Object.prototype.hasOwnProperty.call(n,s)&&("mean"==e.calc?r.push((o[t][s]||0)/(o[t][s+"count"]||1)):r.push(o[t][s]||0));r.push(o[t].Total),this.__pivot.records.push(r),this.__pivot.table.records++}return this.__pivot},subtable:function(e){if(this.__subt=new s.Table,e.fields){e.columns=[];for(let t=0;t<e.fields.length;t++)for(let o=0;o<this.fields.length;o++)this.fields[o].id==e.fields[t]&&e.columns.push(o)}for(let t=0;t<e.columns.length;t++)this.__subt.fields.push({id:String(this.fields[e.columns[t]].id)}),this.__subt.table.fields++;for(const t in this.records){let o=[];for(let r=0;r<e.columns.length;r++)o.push(this.records[t][e.columns[r]]);this.__subt.records.push(o),this.__subt.table.records++}return this.__subt},sort:function(e,t){let o=this.column(e).values(),r=0;for(let e=0;e<Math.min(o.length,10);e++)isNaN(parseFloat(String(o[e]).replace(",",".")))||r++;let n=[];if(r)for(let e=0;e<o.length;e++)n.push({index:e,value:Number(String(o[e]).replace(",","."))});else for(let e=0;e<o.length;e++)n.push({index:e,value:o[e]});t&&"DOWN"==t?n.sort((function(e,t){return e.value>t.value?-1:1})):n.sort((function(e,t){return e.value<t.value?-1:1}));let s=[];for(let e=0;e<n.length;e++)s.push(this.records[n[e].index]);return this.records=s,this},append:function(e){if(this.table.fields.length!=e.table.fields.length)return null;for(let t=0;t<this.table.fields.length;t++)if(this.table.fields[t].id!=e.table.fields[t].id)return null;let t=e.records;for(let e=0;e<t.length;e++)this.records.push(t[e]);return this.table.records=this.records.length,this},json:function(){this.__json=[];for(const e in this.records){let t={};for(const o in this.fields)t[String(this.fields[o].id)]=this.records[e][o];this.__json.push(t)}return this.__json}},__myNumber=function(e){let t=parseFloat(e.replace(/\./g,"").replace(/\,/g,"."));return isNaN(t)?0:t},__scanValue=function(e){let t=null;return String(e).match(/,/)?(t=parseFloat(String(e).replace(/\./gi,"").replace(/,/gi,".")),isNaN(t)?0:t):(t=parseFloat(String(e).replace(/ /gi,"")),isNaN(t)?0:t)},s.Table.prototype.addTimeColumns=function(e){if(!e.source)return null;for(const t in this.fields)if(this.fields[t].id==e.source){let o=e.create||["date","year","month","day","hour"];for(let e=0;e<o.length;e++)this.fields.push({id:String(o[e])}),this.table.fields++;let r=this.records.length,n=0;for(n=0;n<r;n++){let e=new Date(this.records[n][t]);if(e)for(let t=0;t<o.length;t++)switch(o[t]){case"date":let t=String(e.getDate())+"."+String(e.getMonth()+1)+"."+String(e.getFullYear());this.records[n].push(t);break;case"year":this.records[n].push(e.getFullYear());break;case"month":this.records[n].push(e.getMonth()+1);break;case"day":this.records[n].push(e.getDay());break;case"hour":this.records[n].push(e.getHours());break}}}return this},s.Column=function(){this.table=null,this.index=null,this.valueA=null},s.Column.prototype={values:function(){this.valueA=[];for(const e in this.table.records)this.valueA.push(this.table.records[e][this.index]);return this.valueA},uniqueValues:function(){this.valueA=[];for(const e in this.table.records)this.valueA.push(this.table.records[e][this.index]);return this.valueA.filter(n)},map:function(e){for(const t in this.table.records)this.table.records[t][this.index]=e(this.table.records[t][this.index],this.table.records[t],this.index);return this},rename:function(e){return this.table.fields[this.index].id=e,this},remove:function(){this.table.fields.splice(this.index,1);for(const e in this.table.records)this.table.records[e].splice(this.index,1);return this.table.table.fields--,this}},s.Feed.prototype.column=function(e){return this.dbtable.column(e)},s.Feed.prototype.select=function(e){return this.dbtable.select(e)},s.Feed.prototype.aggregate=function(e,t){return this.dbtable.aggregate(e,t)},s.Feed.prototype.revert=function(){return this.dbtable.revert()},s.Feed.prototype.reverse=function(){return this.dbtable.reverse()},s.Feed.prototype.pivot=function(e){return this.dbtable.pivot(e)},s.Feed.prototype.subtable=function(e){return this.dbtable.subtable(e)},s.Feed.prototype.addTimeColumns=function(e){return this.dbtable.addTimeColumns(e)},s.Broker=function(e){this.souceQueryA=[],this.options=e||{},e&&this.parseDefinition(e),this.onNotify=function(){},this.onError=function(e){alert("error loading data:"+e)}},s.Broker.prototype=new s.Feed,s.Broker.prototype={addSource:function(e,t){return _LOG("Data.Broker.addSource: "+e),this.souceQueryA.push({url:e,type:t,data:null,result:null,next:this}),this},setCallback:function(e){return this.callback=e,this},realize:function(e){this.callback=e||this.callback;for(const e in this.souceQueryA)if(this.souceQueryA[e].url&&!this.souceQueryA[e].result)return this.getData(this.souceQueryA[e]),this;this.data=[];for(const e in this.souceQueryA)this.data.push(this.souceQueryA[e].data||new s.Table);return this.callback(this.data),this},error:function(e){return this.onError=e||this.onError,this},notify:function(e){return this.onNotify=e||this.onNotify,this}},s.Broker.prototype.parseDefinition=function(e){this.callback=e.callback||null},s.Broker.prototype.getData=function(e){this.onNotify(e),e.feed=s.feed({source:e.url,type:e.type,options:e.next.options,parent:this}).load((function(t){e.data=t,e.data.raw=e.feed.data,this.parent.onNotify(e),e.result="success",e.next.realize()})).error((function(t){this.parent.onError(e.url),e.data=null,e.result="error",e.next.realize()}))},s.Broker.prototype.setData=function(e){this.parent.__doCreateTableDataObject(e,null,this.parent.options)},s.Feed.prototype.broker=function(e){let t=new s.Broker(e);return t.parent=this,t},s.broker=function(){return new s.Broker},s.provider=function(){return new s.Broker},s.Merger=function(e){this.sourceA=[],this.options=e||{},e&&this.parseDefinition(e)},s.Merger.prototype={addSource:function(e,t){return this.sourceA.push({data:e,opt:t}),this},setOutputColumns:function(e){return this.outColumnsA=e,this},realize:function(e){this.callback=e||this.callback,_LOG("DataMerger: >>>");let t=[];for(const e in this.sourceA){let o=this.sourceA[e];o.opt.columns=o.opt.columns||o.data.columnNames(),o.opt.label=o.opt.label||[],o.opt.columns=r(o.opt.columns),o.opt.label=r(o.opt.label),this.sourceA[e].data||a("DataMerger: source '"+e+"' not found"),this.sourceA[e].data[0]||(this.sourceA[e].data=this.sourceA[e].data.getArray()),this.sourceA[e].data[0]||a("DataMerger: source '"+e+"' not found or not of type Array");let n=[];for(const t in this.sourceA[e].data[0]){this.sourceA[e].data[0][t]==this.sourceA[e].opt.lookup&&(n[this.sourceA[e].opt.lookup]=t);for(const o in this.sourceA[e].opt.columns)this.sourceA[e].opt.label[o]||(this.sourceA[e].opt.label[o]=this.sourceA[e].opt.columns[o]+"."+(Number(e)+1)),this.sourceA[e].data[0][t]==this.sourceA[e].opt.columns[o]&&(n[this.sourceA[e].opt.label[o]]=t)}for(const t in this.sourceA[e].opt.columns)n[this.sourceA[e].opt.label[t]]||_LOG("DataMerger: '"+this.sourceA[e].opt.label[t]+"' not found");t.push(n)}let o=[];for(const e in this.sourceA)for(const t in this.sourceA[e].opt.label)o.push(this.sourceA[e].opt.label[t]);if(!this.outColumnsA){this.outColumnsA=[];for(const e in o)this.outColumnsA.push(o[e])}let n=[];for(const e in this.outColumnsA)for(const o in t)for(const r in t[o])r==this.outColumnsA[e]&&(n[r]={input:o,index:t[o][r]});for(const e in this.outColumnsA)if(!n[this.outColumnsA[e]])for(const t in this.sourceA[0].data[0])this.sourceA[0].data[0][t]==this.outColumnsA[e]&&(n[this.outColumnsA[e]]={input:0,index:t});this.namedSourceA=[];for(let e=1;e<this.sourceA.length;e++){this.namedSourceA[e]=[];for(let o=1;o<this.sourceA[e].data.length;o++)this.namedSourceA[e][String(this.sourceA[e].data[o][t[e][this.sourceA[e].opt.lookup]])]=this.sourceA[e].data[o]}let i=[];i.push(this.outColumnsA);for(let e=1;e<this.sourceA[0].data.length;e++){let o=String(this.sourceA[0].data[e][[t[0][this.sourceA[0].opt.lookup]]]),r=[];for(const t in this.outColumnsA){let s=n[this.outColumnsA[t]];if(!s)return a('DataMerger - missing "'+this.outColumnsA[t]+'" in label:[...]'),null;0==s.input?r.push(this.sourceA[0].data[e][s.index]):this.namedSourceA[s.input][o]?r.push(this.namedSourceA[s.input][o][s.index]):r.push(" ")}i.push(r)}_LOG("DataMerger: done");let l=new s.Table;return l.setArray(i),this.callback&&this.callback(l),l},error:function(e){return this.onError=e||this.onError,this}},s.merger=function(){return new s.Merger};var a=function(e){}}(window,document);